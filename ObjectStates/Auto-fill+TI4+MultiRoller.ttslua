-- ############################################################################
-- #### START #include <~/CrLua/Objects/AutoFillMultiRoller>
-- ############################################################################

-------------------------------------------------------------------------------
--- Auto-fill the TTS/TI4 MultiRoller
-- TTS/TI4 by Darth Batman and Raptor1210.
-- TI4 MultiRoller by the_Mantis and GarnetBear
-- @author Darrell
--
-- This script keeps track of the last activated system (command token dropped
-- by the active player this turn), and fills the MultiRoller.
--
-- The active fleet takes into account if the MultiRoller belongs to attacker,
-- defender, or third party who happens to have range with an adjacent PDS2.
-- Per-planet combats assign units to the closest planet.
--
-- It scans for Antimass Deflector on the other party, and selects the best unit
-- for Plasma Scoring.
--
-- PDS2 targets adjacent and through-wormhole, including the Creuss flagship's
-- mobile delta wormhole.  The Winnu flagship sets its count to the number of
-- non-fighter opponents.  The Xxcha flagship has an adjacent-reaching PDS.
--
-- Creuss players might want to enable "grid" on their homeworld so it aligns well
-- with the table grid, making sure units on the planet are counted.
--
-- This requires Turns be enabed to ignore when a non-active player touches a
-- command token.  (Turns are automatically enabled via the "place trade goods
-- and set turns" button.)  For a hot-seat like environment, a player must
-- change color to current active turn in order to recognize system activation.
-------------------------------------------------------------------------------

local TAG = 'AutoFillMultiRoller'

local data = {
    colorToMultiRoller = false,
    perPlanetButtons = {}  -- map from function name to button index
}

local AUTOFILL_TYPE = {
    SPACE_CANNON_OFFENSE = { name = 'Space Cannon Offense', rollType = 'spaceCannon' },
    ANTI_FIGHTER_BARRAGE = { name = 'Anti-Fighter Barrage', rollType = 'antiFighterBarrage' },
    SPACE_COMBAT = { name = 'Space Combat', rollType = 'spaceCombat' },
    BOMBARDMENT = { name = 'Bombardment', perPlanet = true, rollType = 'bombardment' },
    SPACE_CANNON_DEFENSE = { name = 'Space Cannon Defense', perPlanet = true, rollType = 'spaceCannon' },
    GROUND_COMBAT = { name = 'Ground Combat', perPlanet = true, rollType = 'groundCombat' }
}

-------------------------------------------------------------------------------

-- Register click functions.
function getOnClickFunctionName(autoFillType, planetIndex)
    assert(AUTOFILL_TYPE[autoFillType])
    return 'onClick_' .. autoFillType .. (planetIndex and ('_' .. planetIndex) or '')
end
function getOnClickFunctionBody(autoFillType, planetIndex)
    local function body(clickObject, clickerColor, altClick)
        autoFill({
            clickerColor = clickerColor,
            altClick = altClick and true or false,
            autoFillType = autoFillType,
            planetIndex = planetIndex or false
        })
    end
    return body
end
function createOnClickFunctions()
    for autoFillType, attrs in pairs(AUTOFILL_TYPE) do
        if attrs.perPlanet then
            for i = 1, 5 do
                local n = getOnClickFunctionName(autoFillType, i)
                local f = getOnClickFunctionBody(autoFillType, i)
                self.setVar(n, f)
            end
        else
            local n = getOnClickFunctionName(autoFillType, false)
            local f = getOnClickFunctionBody(autoFillType, false)
            self.setVar(n, f)
        end
    end
end
createOnClickFunctions()

-------------------------------------------------------------------------------

function getHelperClient(helperObjectName)
    local function getHelperObject()
        for _, object in ipairs(getAllObjects()) do
            if object.getName() == helperObjectName then return object end
        end
        error('missing object "' .. helperObjectName .. '"')
    end
    -- Nested tables are considered cross script.  Make a local copy.
    local function copyTable(t)
        if t and type(t) == 'table' then
            local copy = {}
            for k, v in pairs(t) do
                copy[k] = type(v) == 'table' and copyTable(v) or v
            end
            t = copy
        end
        return t
    end
    local helperObject = false
    local function getCallWrapper(functionName)
        helperObject = helperObject or getHelperObject()
        if not helperObject.getVar(functionName) then error('missing ' .. helperObjectName .. '.' .. functionName) end
        return function(parameters) return copyTable(helperObject.call(functionName, parameters)) end
    end
    return setmetatable({}, { __index = function(t, k) return getCallWrapper(k) end })
end
local _systemHelper = getHelperClient('TI4_SYSTEM_HELPER')
local _unitHelper = getHelperClient('TI4_UNIT_HELPER')
local _zoneHelper = getHelperClient('TI4_ZONE_HELPER')

local _bombardmentPlasmaScoringOnPlanet = false
local _rollOnSelf = false

-------------------------------------------------------------------------------

function onLoad(save_state)
    CrLua.Log.d(TAG, 'onLoad')
    self.addContextMenuItem('Toggle roll nearby', function() _rollOnSelf = not _rollOnSelf end)
    Wait.frames(updateUi, 2)
end

function onSystemActivation(system)
    CrLua.Log.d(TAG, 'onSystemActivation')
    _bombardmentPlasmaScoringOnPlanet = false
    updateUi()
end

-------------------------------------------------------------------------------

function updateColorToMultiRoller()
    local multiRollers = {}
    local colorToPosition = {}
    for _, object in ipairs(getAllObjects()) do
        local name = object.getName()
        if string.match(name, '^TI4 MultiRoller') then
            table.insert(multiRollers, object)
        end
        local color = string.match(name, '^Command Sheet %((%a+)%)$')
        if color then
            colorToPosition[color] = object.getPosition()
        end
    end

    data.colorToMultiRoller = {}
    for color, position in pairs(colorToPosition) do
        local function distance(multiRoller)
            return CrLua.Util.distanceSq(multiRoller.getPosition(), position)
        end
        local _, multiRoller = CrLua.Util.min(multiRollers, distance)
        data.colorToMultiRoller[color] = multiRoller
    end
end

-------------------------------------------------------------------------------

function updateUi()
    local system = _systemHelper.getActivatedSystem()
    local planets = system and system.planets or false

    -- Object in game space is x=1.43, y=0.2, z=2
    -- Object in button space is x=715, y=0.2, z=1000

    local NO_LABEL = '---'

    local fontSize = 44
    local labelFontSize = 30
    local scaleUpDown = 4

    local gapXZ = 0.04
    local gapU = gapXZ / 1.43
    local hMajorZ = 0.3
    local hMinorZ = 0.03

    local hMajor = hMajorZ / 2 * 1000
    local hMinor = hMinorZ / 2 * 1000

    local panelX = 1.43 - (gapXZ * 2)  -- remove gap padding

    self.clearButtons()

    local function numColsAttrs(cols)
        local gapTotalU = gapU * (cols - 1)
        local colTotalU = 1 - gapTotalU
        local w = colTotalU / cols
        local u0 = w / 2
        local du = w + gapU

        -- Slightly off for some reason.  Ad-hoc fix.
        --u0 = u0 - (cols - 1) * 0.01
        w = w - 0.01 + (cols - 1) * 0.01

        return {
            x0 = (u0 * panelX) - (panelX / 2),
            dx = du * panelX,
            w = w * (panelX * 500)
        }
    end

    -- ROW
    local attrs = numColsAttrs(2)
    local x = attrs.x0
    local y = 0.21
    local z = -1 + gapXZ + (hMajorZ / 2)
    local w = attrs.w
    local h = hMajor
    self.createButton({
        click_function = getOnClickFunctionName('SPACE_CANNON_OFFENSE', false),
        function_owner = self,
        label          = 'Space Cannon\nOffense',
        position       = { x = x, y = y, z = z },
        rotation       = { x = 0, y = 0, z = 0 },
        scale          = { x = 1/scaleUpDown, y = 1, z = 1/scaleUpDown },
        width          = w * scaleUpDown,
        height         = h * scaleUpDown,
        font_size      = fontSize * scaleUpDown,
        tooltip        = 'Space Cannon Offense',
    })
    x = x + attrs.dx
    self.createButton({
        click_function = getOnClickFunctionName('ANTI_FIGHTER_BARRAGE', false),
        function_owner = self,
        label          = 'Anti-Fighter\nBarrage',
        position       = { x = x, y = y, z = z },
        rotation       = { x = 0, y = 0, z = 0 },
        scale          = { x = 1/scaleUpDown, y = 1, z = 1/scaleUpDown },
        width          = attrs.w * scaleUpDown,
        height         = h * scaleUpDown,
        font_size      = fontSize * scaleUpDown,
        tooltip        = 'Anti-Fighter Barrage',
    })

    -- ROW
    z = z + gapXZ + hMajorZ + hMinorZ
    --z = z + gapXZ + hMajorZ
    local attrs = numColsAttrs(1)
    local x = attrs.x0
    local w = attrs.w
    self.createButton({
        click_function = getOnClickFunctionName('SPACE_COMBAT', false),
        function_owner = self,
        label          = 'Space Combat',
        position       = { x = x, y = y, z = z },
        rotation       = { x = 0, y = 0, z = 0 },
        scale          = { x = 1/scaleUpDown, y = 1, z = 1/scaleUpDown },
        width          = w * scaleUpDown,
        height         = h * scaleUpDown,
        font_size      = fontSize * scaleUpDown,
        tooltip        = 'Space combat',
    })

    -- LABEL+ROW
    z = z + gapXZ + (hMajorZ + hMinorZ) / 2
    self.createButton({
        click_function = 'doNothing',
        function_owner = self,
        label          = string.upper('Bombardment'),
        position       = { x = 0, y = y, z = z },
        rotation       = { x = 0, y = 0, z = 0 },
        scale          = { x = 1/scaleUpDown, y = 1, z = 1/scaleUpDown },
        width          = 0,
        height         = 0,
        font_size      = labelFontSize * scaleUpDown,
        tooltip        = nil,
    })
    z = z + gapXZ + (hMajorZ + hMinorZ) / 2
    local attrs = numColsAttrs(planets and #planets or 1)
    local x = attrs.x0
    local w = attrs.w
    if not planets then
        self.createButton({
            click_function = 'doNothing',
            function_owner = self,
            label          = NO_LABEL,
            position       = { x = x, y = y, z = z },
            rotation       = { x = 0, y = 0, z = 0 },
            scale          = { x = 1/scaleUpDown, y = 1, z = 1/scaleUpDown },
            width          = w * scaleUpDown,
            height         = h * scaleUpDown,
            font_size      = fontSize * scaleUpDown,
            tooltip        = nil,
        })
    else
        for i, planet in ipairs(planets) do
            self.createButton({
                click_function = getOnClickFunctionName('BOMBARDMENT', i),
                function_owner = self,
                label          = planet.name,
                position       = { x = x, y = y, z = z },
                rotation       = { x = 0, y = 0, z = 0 },
                scale          = { x = 1/scaleUpDown, y = 1, z = 1/scaleUpDown },
                width          = w * scaleUpDown,
                height         = h * scaleUpDown,
                font_size      = fontSize * scaleUpDown,
                tooltip        = 'Bombard ' .. planet.name,
            })
            x = x + attrs.dx
        end
    end

    -- LABEL+ROW
    z = z + gapXZ + (hMajorZ + hMinorZ) / 2
    self.createButton({
        click_function = 'doNothing',
        function_owner = self,
        label          = string.upper('Space Cannon Defense'),
        position       = { x = 0, y = y, z = z },
        rotation       = { x = 0, y = 0, z = 0 },
        scale          = { x = 1/scaleUpDown, y = 1, z = 1/scaleUpDown },
        width          = 0,
        height         = 0,
        font_size      = labelFontSize * scaleUpDown,
        tooltip        = nil,
    })
    z = z + gapXZ + (hMajorZ + hMinorZ) / 2
    local attrs = numColsAttrs(planets and #planets or 1)
    local x = attrs.x0
    local w = attrs.w
    if not planets then
        self.createButton({
            click_function = 'doNothing',
            function_owner = self,
            label          = NO_LABEL,
            position       = { x = x, y = y, z = z },
            rotation       = { x = 0, y = 0, z = 0 },
            scale          = { x = 1/scaleUpDown, y = 1, z = 1/scaleUpDown },
            width          = w * scaleUpDown,
            height         = h * scaleUpDown,
            font_size      = fontSize * scaleUpDown,
            tooltip        = nil,
        })
    else
        for i, planet in ipairs(planets) do
            self.createButton({
                click_function = getOnClickFunctionName('SPACE_CANNON_DEFENSE', i),
                function_owner = self,
                label          = planet.name,
                position       = { x = x, y = y, z = z },
                rotation       = { x = 0, y = 0, z = 0 },
                scale          = { x = 1/scaleUpDown, y = 1, z = 1/scaleUpDown },
                width          = w * scaleUpDown,
                height         = h * scaleUpDown,
                font_size      = fontSize * scaleUpDown,
                tooltip        = 'Space Cannon Defense on ' .. planet.name,
            })
            x = x + attrs.dx
        end
    end

    -- LABEL+ROW
    z = z + gapXZ + (hMajorZ + hMinorZ) / 2
    self.createButton({
        click_function = 'doNothing',
        function_owner = self,
        label          = string.upper('Ground Combat'),
        position       = { x = 0, y = y, z = z },
        rotation       = { x = 0, y = 0, z = 0 },
        scale          = { x = 1/scaleUpDown, y = 1, z = 1/scaleUpDown },
        width          = 0,
        height         = 0,
        font_size      = labelFontSize * scaleUpDown,
        tooltip        = nil,
    })
    z = z + gapXZ + (hMajorZ + hMinorZ) / 2
    local attrs = numColsAttrs(planets and #planets or 1)
    local x = attrs.x0
    local w = attrs.w
    if not planets then
        self.createButton({
            click_function = 'doNothing',
            function_owner = self,
            label          = NO_LABEL,
            position       = { x = x, y = y, z = z },
            rotation       = { x = 0, y = 0, z = 0 },
            scale          = { x = 1/scaleUpDown, y = 1, z = 1/scaleUpDown },
            width          = w * scaleUpDown,
            height         = h * scaleUpDown,
            font_size      = fontSize * scaleUpDown,
            tooltip        = nil,
        })
    else
        for i, planet in ipairs(planets) do
            self.createButton({
                click_function = getOnClickFunctionName('GROUND_COMBAT', i),
                function_owner = self,
                label          = planet.name,
                position       = { x = x, y = y, z = z },
                rotation       = { x = 0, y = 0, z = 0 },
                scale          = { x = 1/scaleUpDown, y = 1, z = 1/scaleUpDown },
                width          = w * scaleUpDown,
                height         = h * scaleUpDown,
                font_size      = fontSize * scaleUpDown,
                tooltip        = 'Ground combat on ' .. planet.name,
            })
            x = x + attrs.dx
        end
    end
end

function doNothing()
    --
end

-------------------------------------------------------------------------------

--- Get the hex and adjacent hexes from a position.
function getHexAndAdjacent(position, playerColor)
    CrLua.Log.d(TAG, 'getHexAndAdjacent')
    assert(type(position) == 'table' and type(position.x) == 'number')
    assert(type(playerColor) == 'string')

    -- Get this hex, and adjacent hexes.
    local hex = _systemHelper.hexFromPosition(position)
    local adjacentHexes = _systemHelper.hexNeighbors(hex)

    -- Include through-wormhole.
    local adjacentWormholeHexes = _systemHelper.hexAdjacentWormholes({
        hex = hex,
        playerColor = playerColor
    })
    for _, wormholeHex in ipairs(adjacentWormholeHexes) do
        table.insert(adjacentHexes, wormholeHex)
    end

    -- Remove any duplicates.
    adjacentHexes = CrLua.List.unique(adjacentHexes)

    return hex, adjacentHexes
end

function getHexToUnits(units)
    CrLua.Log.d(TAG, 'getHexToUnits')
    assert(type(units) == 'table')

    local hexToUnits = {}
    for _, unit in ipairs(units) do
        local entry = hexToUnits[unit.hex]
        if not entry then
            entry = {}
            hexToUnits[unit.hex] = entry
        end
        table.insert(entry, unit)
    end
    return hexToUnits
end

-------------------------------------------------------------------------------

function rewritePositionAndHexForInArenaUnits(hex, units)
    CrLua.Log.d(TAG, 'rewritePositionAndHexForInArenaUnits')
    assert(type(hex) == 'string' and type(units) == 'table')

    local arenaName = 'TI4 Auto-fill MultiRoller Arena'

    -- Allow multiple arena objects to coexist.
    local bbToArenaObject = false
    for _, object in ipairs(getAllObjects()) do
        if object.getName() == arenaName then
            local bounds = object.getBounds()
            local bb = {
                min = {
                    x = bounds.center.x - bounds.size.x,
                    z = bounds.center.z - bounds.size.z,
                },
                max = {
                    x = bounds.center.x + bounds.size.x,
                    z = bounds.center.z + bounds.size.z,
                },
            }
            bbToArenaObject = bbToArenaObject or {}
            bbToArenaObject[bb] = object
        end
    end
    if not bbToArenaObject then
        CrLua.Log.d(TAG, 'getArenaUnits: no arenas')
        return false
    end

    local activatedSystem = _systemHelper.getActivatedSystem()
    local activatedSystemObject = getObjectFromGUID(activatedSystem.guid)

    for _, unit in ipairs(units) do
        local p = unit.position
        for bb, arenaObject in pairs(bbToArenaObject) do
            if p.x >= bb.min.x and p.x <= bb.max.x and p.z >= bb.min.z and p.z <= bb.max.z then
                -- unit is in arena bounding box.  Get in-system position to
                -- make sure it is actually in the hex.
                p = activatedSystemObject.positionToWorld(arenaObject.positionToLocal(p))
                if hex == _systemHelper.hexFromPosition(p) then
                    -- Overwrite position data to act like in-hex rather than in-arena.
                    unit.hex = hex
                    unit.position = p  -- world position inside activated system
                end
            end
        end
    end

    return true
end

function getOpponentColor(selfColor, activatingColor, unitsInHex)
    CrLua.Log.d(TAG, 'getOpponentColor')
    assert(type(selfColor) == 'string' and type(activatingColor) == 'string' and type(unitsInHex) == 'table')

    -- If self is not the activating player, then activating player is enemy.
    -- (This could be a third player firing PDS2 from an adjacent hex).
    if selfColor ~= activatingColor then
        return activatingColor
    end

    -- If there are any ships this is a space combat.  Get ship color.
    local genericAttrs = _unitHelper.getUnitAttributes({})
    for _, unit in ipairs(unitsInHex) do
        if unit.color and unit.color ~= selfColor then
            if genericAttrs[unit.unitType].spaceCombat then
                return unit.color
            end
        end
    end

    -- Otherwise ground combat?  Get any unit color (assume already filtered to planet).
    for _, unit in ipairs(unitsInHex) do
        if unit.color and unit.color ~= selfColor then
            return unit.color
        end
    end
end

-------------------------------------------------------------------------------

local _autoFillQueue = {}

function autoFill(params)
    table.insert(_autoFillQueue, params)
    startLuaCoroutine(self, 'autoFillCoroutine')
end

function autoFillCoroutine()
    CrLua.Log.d(TAG, 'autoFillCoroutine')
    local params = assert(table.remove(_autoFillQueue))
    assert(type(params.clickerColor) == 'string', 'clickerColor')
    assert(type(params.altClick) == 'boolean', 'altClick')
    assert(AUTOFILL_TYPE[params.autoFillType], 'autoFillType')
    assert(not params.planetIndex or type(params.planetIndex) == 'number', 'planetIndex')

    local autofillTypeAttributes = assert(AUTOFILL_TYPE[params.autoFillType])

    updateColorToMultiRoller()
    coroutine.yield(0)

    local multiRoller = data.colorToMultiRoller[params.clickerColor]
    if not multiRoller then
        printToAll(TAG .. ': no MultiRoller for ' .. params.clickerColor, {1,0,0})
        return 1
    end

    local system = _systemHelper.getActivatedSystem()
    local systemObject = system and getObjectFromGUID(system.guid)
    if not systemObject then
        printToAll(TAG .. ': no activated system', {1,0,0})
        return 1
    end

    local activatingColor = Turns.turn_color
    if not activatingColor then
        printToAll(TAG .. ': no activating player', {1,0,0})
        return 1
    end

    -- Get units in hex and adjacent (including wormholes) systems.
    CrLua.Log.d(TAG, 'autoFillCoroutine: hexToUnits')
    local hex, adjacentHexes = getHexAndAdjacent(systemObject.getPosition(), params.clickerColor)
    coroutine.yield(0)
    local units = _unitHelper.getUnits()
    coroutine.yield(0)
    rewritePositionAndHexForInArenaUnits(hex, units)
    coroutine.yield(0)
    local hexToUnits = getHexToUnits(units)
    for unitsHex, units in pairs(hexToUnits) do
        hexToUnits[unitsHex] = _unitHelper.fillUnitColors(units)  -- iteration allows overwrites of existing keys
    end
    coroutine.yield(0)

    local colorToUnitOverrides = _unitHelper.getColorToUnitOverrides()
    coroutine.yield(0)
    local colorToUnitModifiers = _unitHelper.getColorToUnitModifiers()
    coroutine.yield(0)

    -- Get per-hex unit attributes.  Per-hex because sometimes flagships modify
    -- peers, opponent non-fighter ships counts matter, etc.
    local function getUnitAttrs(units, color, opponentColor)
        local colorToUnits = _unitHelper.getColorToUnits(units)
        local unitTypeToCount = _unitHelper.getUnitTypeToCount(colorToUnits[color] or {})
        local opponentUnitTypeToCount = _unitHelper.getUnitTypeToCount(colorToUnits[opponentColor] or {})

        local unitOverrides = colorToUnitOverrides[color] or {}
        local unitAttrs = _unitHelper.getUnitAttributes(unitOverrides)

        -- Apply flagships.
        unitAttrs = _unitHelper.applyFlagshipModifiers({
            unitAttrs = assert(unitAttrs),
            myUnitTypeToCount = unitTypeToCount,
            opponentUnitTypeToCount = opponentUnitTypeToCount
        })

        -- Apply unit modifiers.
        unitAttrs = _unitHelper.applyUnitModifiers({
            unitAttrs = assert(unitAttrs),
            myColor = color,
            myUnitModifiers = colorToUnitModifiers[color] or {},
            myUnitTypeToCount = unitTypeToCount,
            opponentColor = opponentColor,
            opponentUnitModifiers = colorToUnitModifiers[opponentColor] or {},
            opponentUnitTypeToCount = opponentUnitTypeToCount
        })

        return unitAttrs
    end

    -- If a planet is given, restrict to ground combat units.  Need to get
    -- attributes in order to apply fighters-on-ground, even through do not yet
    -- know opponent color (attributes may be slightly off, but good enough).
    local planet = false
    if params.planetIndex then
        CrLua.Log.d(TAG, 'autoFillCoroutine: restricting to planet')
        if system and system.planets and #system.planets >= params.planetIndex then
            planet = system.planets[params.planetIndex].name

            local function inPlanetZone(unit)
                if unit.groundCombat and unit.groundCombat.anyPlanet then
                    return true
                end
                local p = _systemHelper.planetFromPosition({
                    systemGuid = system.guid,
                    position = unit.position,
                    exact = false
                })
                return p and (p.name == planet)
            end

            for unitsHex, units in pairs(hexToUnits) do
                local useUnits = {}
                if unitsHex == hex then
                    local units = hexToUnits[hex]
                    for _, unit in ipairs(units) do
                        if inPlanetZone(unit) then
                            table.insert(useUnits, unit)
                        end
                    end
                end
                hexToUnits[unitsHex] = useUnits
            end
        end
    end
    coroutine.yield(0)

    -- Deduce enemy color as the only non-self in the system.
    local selfColor = params.clickerColor
    local enemyColor = getOpponentColor(selfColor, activatingColor, hexToUnits[hex] or {})

    -- Split into self and enemy units.
    CrLua.Log.d(TAG, 'autoFillCoroutine: split self/enemy')
    local adjacentHexSet = {}
    for _, adjacentHex in ipairs(adjacentHexes) do
        adjacentHexSet[adjacentHex] = true
    end
    local selfUnitsInHex = {}
    local enemyUnitsInHex = {}
    local selfUnitsAdacent = {}
    for unitHex, units in pairs(hexToUnits) do
        for _, unit in ipairs(units) do
            if unitHex == hex then
                if unit.color == selfColor then
                    table.insert(selfUnitsInHex, unit)
                elseif unit.color == enemyColor then
                    table.insert(enemyUnitsInHex, unit)
                end
            elseif adjacentHexSet[unit.hex] and unit.color == selfColor then
                table.insert(selfUnitsAdacent, unit)
            end
        end
    end
    local selfUnitTypeToCount = _unitHelper.getUnitTypeToCount(selfUnitsInHex)
    local enemyUnitTypeToCount = _unitHelper.getUnitTypeToCount(enemyUnitsInHex)
    local selfAdjUnitTypeToCount = _unitHelper.getUnitTypeToCount(selfUnitsAdacent)

    -- Is bombardment allowed?
    CrLua.Log.d(TAG, 'autoFillCoroutine: checking planetary shield')
    local planetaryShield = false
    if enemyColor then
        local unitTypeToAttrs = assert(getUnitAttrs(hexToUnits[hex] or {}, enemyColor, selfColor))
        for unitType, attrs in pairs(unitTypeToAttrs) do
            if attrs.planetaryShield and (enemyUnitTypeToCount[unitType] or 0) > 0 then
                planetaryShield = true
                break
            end
        end
    end
    local unitTypeToAttrs = assert(getUnitAttrs(hexToUnits[hex] or {}, selfColor, enemyColor))
    for unitType, attrs in pairs(unitTypeToAttrs) do
        if attrs.disablePlanetaryShield and (selfUnitTypeToCount[unitType] or 0) > 0 then
            planetaryShield = false
            break
        end
    end
    coroutine.yield(0)

    -- Apply any per-unit limits (Experimental Battlestation).
    local function applyUnitLimit(unitLimit, inHex, adjHex)
        local avail = unitLimit
        inHex = math.min(inHex, avail)
        avail = avail - inHex
        adjHex = math.min(adjHex, avail)
        return inHex, adjHex
    end

    -- Now get just the units that matter for the combat type.
    CrLua.Log.d(TAG, 'autoFillCoroutine: getting fill units')
    local fillUnitTypeToCount = {}
    local adjacentUnitTypeToCount = {}
    if autofillTypeAttributes == AUTOFILL_TYPE.SPACE_CANNON_OFFENSE then

        for unitType, attrs in pairs(unitTypeToAttrs) do
            if attrs.spaceCannon then
                fillUnitTypeToCount[unitType] = selfUnitTypeToCount[unitType] or 0
                if attrs.spaceCannon.range and attrs.spaceCannon.range > 0 then
                    fillUnitTypeToCount[unitType] = fillUnitTypeToCount[unitType] + (selfAdjUnitTypeToCount[unitType] or 0)
                    adjacentUnitTypeToCount[unitType] = (adjacentUnitTypeToCount[unitType] or 0) + (selfAdjUnitTypeToCount[unitType] or 0)
                end
                if attrs.spaceCannon.unitLimit then
                    local a, b = applyUnitLimit(attrs.spaceCannon.unitLimit, fillUnitTypeToCount[unitType], adjacentUnitTypeToCount[unitType])
                    fillUnitTypeToCount[unitType] = a
                    adjacentUnitTypeToCount[unitType] = b
                end
            end
        end

    elseif autofillTypeAttributes == AUTOFILL_TYPE.ANTI_FIGHTER_BARRAGE then

        for unitType, attrs in pairs(unitTypeToAttrs) do
            if attrs.antiFighterBarrage then
                fillUnitTypeToCount[unitType] = selfUnitTypeToCount[unitType] or 0
            end
        end

    elseif autofillTypeAttributes == AUTOFILL_TYPE.SPACE_COMBAT then

        for unitType, attrs in pairs(unitTypeToAttrs) do
            if attrs.spaceCombat then
                fillUnitTypeToCount[unitType] = selfUnitTypeToCount[unitType] or 0
            end
        end

    elseif autofillTypeAttributes == AUTOFILL_TYPE.BOMBARDMENT then

        if not planetaryShield then
            for unitType, attrs in pairs(unitTypeToAttrs) do
                if attrs.bombardment then
                    fillUnitTypeToCount[unitType] = selfUnitTypeToCount[unitType] or 0
                end
            end

            if not _bombardmentPlasmaScoringOnPlanet then
                _bombardmentPlasmaScoringOnPlanet = planet
            end

        end

    elseif autofillTypeAttributes == AUTOFILL_TYPE.SPACE_CANNON_DEFENSE then

        for unitType, attrs in pairs(unitTypeToAttrs) do
            if attrs.spaceCannon then
                fillUnitTypeToCount[unitType] = selfUnitTypeToCount[unitType] or 0
                if unitType == 'Space Dock' then
                    fillUnitTypeToCount[unitType] = 0  -- Experimental Battlestation does not apply
                end
            end
        end

    elseif autofillTypeAttributes == AUTOFILL_TYPE.GROUND_COMBAT then

        for unitType, attrs in pairs(unitTypeToAttrs) do
            if attrs.groundCombat then
                fillUnitTypeToCount[unitType] = selfUnitTypeToCount[unitType] or 0
            end
        end

        -- Reset for L1Z1X Harrow (bombardment each ground combat round).
        _bombardmentPlasmaScoringOnPlanet = false

    else
        error(TAG .. ' unknown type "' .. typeAttributes.name .. "'")
    end

    if unitTypeToAttrs['Flagship'].spaceCombat.diceAsCount then
        fillUnitTypeToCount['Flagship'] = unitTypeToAttrs['Flagship'].spaceCombat.dice
    end

    -- Compute best PS unit based on available candidates.  Assigns extra die
    -- to the best non-zero-count unit.
    local psUnitType = false
    local fillUnits = {}
    for unitType, count in pairs(fillUnitTypeToCount) do
        if count > 0 then
            table.insert(fillUnits, { unitType = unitType, color = selfColor, count = 1 })
        end
    end
    local fillUnitTypeToAttrs = getUnitAttrs(fillUnits, selfColor, enemyColor)
    for unitType, attrs in pairs(fillUnitTypeToAttrs) do
        if autofillTypeAttributes == AUTOFILL_TYPE.SPACE_CANNON_OFFENSE then
            if attrs.spaceCannon and (attrs.spaceCannon.extraDice or 0) > 0 then
                psUnitType = unitType
                break
            end
        elseif autofillTypeAttributes == AUTOFILL_TYPE.BOMBARDMENT then
            if attrs.bombardment and (attrs.bombardment.extraDice or 0) > 0 then
                psUnitType = unitType
                break
            end
        elseif autofillTypeAttributes == AUTOFILL_TYPE.SPACE_CANNON_DEFENSE then
            if attrs.spaceCannon and (attrs.spaceCannon.extraDice or 0) > 0 then
                psUnitType = unitType
                break
            end
        end
    end

    -- Only bombard the first clicked planet.
    local psAlreadyUsed = false
    if autofillTypeAttributes == AUTOFILL_TYPE.BOMBARDMENT and psUnitType and _bombardmentPlasmaScoringOnPlanet and _bombardmentPlasmaScoringOnPlanet ~= planet then
        psUnitType = false
        psAlreadyUsed = true
    end

    -- Does enemy have PS/AMD?
    local plasmaScoring = false
    local antimassDeflectors = false
    for _, modifier in ipairs(colorToUnitModifiers[selfColor] or {}) do
        if modifier == 'Plasma Scoring' then
            plasmaScoring = true
            break
        end
    end
    for _, modifier in ipairs(colorToUnitModifiers[enemyColor] or {}) do
        if modifier == 'Antimass Deflectors' then
            antimassDeflectors = true
            break
        end
    end

    -- Nebula Defence?
    local extraUnitModifiers = false
    local function isNebula()
        for _, anomaly in ipairs(system.anomalies or {}) do
            if anomaly == 'nebula' then
                return true
            end
        end
    end
    if isNebula() and selfColor ~= activatingColor then
        extraUnitModifiers = extraUnitModifiers or {}
        table.insert(extraUnitModifiers, 'Nebula Defence')
    end

    CrLua.Log.d(TAG, 'autoFillCoroutine: assembling message')
    local prefix = { 'AutoFill ' .. autofillTypeAttributes.name }
    if planet then
        table.insert(prefix, '(' .. planet .. ')')
    end
    table.insert(prefix, selfColor .. ' vs ' .. (enemyColor or '<unknown>'))
    local message = table.concat(prefix, ' ') .. ': '

    local messages = {}
    for unitType, count in pairs(fillUnitTypeToCount) do
        if count > 0 then
            local name = unitType
            if count > 1 and unitType ~= 'Infantry' and unitType ~= 'PDS' then
                name = name .. 's'
            end
            local message = count .. ' ' .. name
            if adjacentUnitTypeToCount[unitType] and adjacentUnitTypeToCount[unitType] > 0 then
                message = message .. ' (' .. adjacentUnitTypeToCount[unitType] .. ' adjacent)'
            end
            if psUnitType == unitType then
                message = message .. ' (Plasma Scoring)'
            end
            table.insert(messages, message)
        end
    end
    if #messages == 0 then
        if autofillTypeAttributes == AUTOFILL_TYPE.BOMBARDMENT and planetaryShield then
            table.insert(messages, 'no units (Planetary Shield)')
        else
            table.insert(messages, 'no units')
        end
    end

    if fillUnitTypeToCount['Flagship'] and fillUnitTypeToCount['Flagship'] > 0 then
        for _, modifier in ipairs(unitTypeToAttrs._flagshipModifiers) do
            if modifier.type == 'mutate' then
                table.insert(messages, '(' .. modifier.name .. ': ' .. modifier.description .. ')')
            end
        end
    end
    for _, modifier in ipairs(unitTypeToAttrs._unitModifiers) do
        if modifier.type == 'mutate' then
            table.insert(messages, '(' .. modifier.name .. ': ' .. modifier.description .. ')')
        end
    end

    if psAlreadyUsed then
        table.insert(messages, '(Plasma Scoring was used on “' .. _bombardmentPlasmaScoringOnPlanet .. '”)')
    end

    if antimassDeflectors then
        table.insert(messages, enemyColor .. ' has Antimass Deflectors')
    end

    if #messages > 0 then
        message = message .. table.concat(messages, ', ') .. '.'
    end
    printToAll(message, params.clickerColor)

    CrLua.Log.d(TAG, 'autoFillCoroutine: injecting MR')
    local doClick = not params.altClick
    multiRoller.call('inject', {
        clickerColor = params.clickerColor,
        unitTypeToCount = fillUnitTypeToCount,
        plasmaScoring = plasmaScoring and true or false,
        antimassDeflectors = antimassDeflectors and true or false,
        rollType = doClick and autofillTypeAttributes.rollType or false,
        extraModifiers = extraUnitModifiers or false,
        rollObjectGuid = _rollOnSelf and self.getGUID(),
    })
    if not doClick then
        printToAll('AutoFill: left click to fill and roll.', params.clickerColor)
    end

    return 1
end

-------------------------------------------------------------------------------

-- ############################################################################
-- #### START #include <~/CrLua/CrLua>
-- ############################################################################

-------------------------------------------------------------------------------
--- Create the base CrLua table, with require function for dependencies.
-- @author Darrell
--
-- Suggested use: at the END of the object script (so #include does not affect
-- line number reporting in the above portion), include CrLua and dependencies:
--
-- #include <~/CrLua/CrLua>
-- #include <~/CrLua/LockGlobals>
--
-- #include <~/CrLua/[OTHER_DEPENDENCY]> (repeat)
--
-- CrLua.assertRequired() -- do this BEFORE lock
-- CrLua.lock()
--
-- -- Optionally enable logging.
-- CrLua.Log.setLogLevel(CrLua.Log.LOG_LEVEL.DEBUG)
-------------------------------------------------------------------------------

local TAG = 'CrLua'

-- Create a GLOBAL CrLua table.
CrLua = CrLua or {}  -- global, <include> wraps in a do .. end block
CrLua._require = { 'LockTable' }

-------------------------------------------------------------------------------
--- Assert all required packages exist.
-- @param extraRequires table : list of additional require entries.
-- @param table : table to search for _require entries, or CrLua if nil.
--
-- Modules add dependencies by having a _require item in their root table,
-- with a list of module names.
-- e.g. CrLua.MyModule = { _require = { 'OtherModule1', 'OtherModule2' } }.
-------------------------------------------------------------------------------
function CrLua.assertRequired(extraRequires, table)
    local seen = {}
    local requireSet = {}
    local haveSet = {}

    if extraRequires then
        for _, name in ipairs(extraRequires) do
            requireSet[name] = true
        end
    end

    local function addRequireEntries(table, packagePath)
        assert(type(table) == 'table')
        if seen[table] then
            return
        end
        seen[table] = true
        if table._require then
            for _, name in ipairs(table._require) do
                requireSet[name] = true
            end
            if packagePath then
                haveSet[packagePath] = true
            end
        end
        for k, v in pairs(table) do
            if type(v) == 'table' and not string.match(k, '^[_%l]') then
                local recurse = type(k) == 'string' and string.match(k, '^%u')
                if recurse then
                    local childPackagePath = (packagePath and (packagePath .. '.') or '') .. k
                    addRequireEntries(v, childPackagePath)
                end
            end
        end
    end
    addRequireEntries(table or CrLua)

    -- Make sure all required packages are present.
    local message = false
    for package, _ in pairs(requireSet) do
        assert(type(package) == 'string')
        -- Descend dot-delimited sub-package names.
        local entry = CrLua
        for subPackage in string.gmatch(package, '[^%.]+') do
            entry = entry and entry[subPackage]
        end
        if not entry then
            message = (message and message .. ', ' or '') .. package
        end
    end
    if message then
        error(TAG .. ': assertRequired missing ' .. message)
    end

    -- Make sure all present packages are required.
    local message = false
    for package, _ in pairs(haveSet) do
        if not requireSet[package] then
            message = (message and message .. ', ' or '') .. package
        end
    end
    if message then
        error(TAG .. ': assertRequired have not-required ' .. message)
    end

end

-------------------------------------------------------------------------------
--- Lock CrLua packages.
--
-- @param tableName string : name of table being locked, or nil for CrLua.
-- @param table : table being locked, or nil for CrLua.
--
-- Make CrLua and nested packages read-only, with access requiring keys exist.
--
-- Locking rules:
--
-- (1.) '_data' is a reserved table name for mutable tables.  Do not lock.
--
-- (2.) If the table starts with a capital letter, make it read-only and
-- require keys exist.  These are packages or constants, attempting to access
-- a missing field is probably a typo.  (Override by adding an
-- _allowMissingKeys = { 'tableName1', 'tableName2'} entry at the same level
-- as the referenced tables.  Such tables allow reads to missing keys, as well
-- as all sub-tables in them.)
--
-- (2.) Otherwise make it read-only but allow reads to missing keys (value nil).
-- One can query membership by checking if a key exists.
--
-- This helps catch typos calling non-existent functions, or overwriting
-- a constant value by mistake.
-------------------------------------------------------------------------------
function CrLua.lock(tableName, table)
    local seen = {}

    local function lockRecursive(tableName, table, allowMissingKeys)
        assert(type(tableName) == 'string' and type(table) == 'table' and type(allowMissingKeys) == 'boolean')

        -- Watch out for cycles!  This might happen if a script defines
        -- an enum table, then later uses one of them in a different table.
        if seen[table] then
            return
        end
        seen[table] = true

        -- Leave _data tables alone.
        local isData = tableName == '_data'
        if isData then
            return
        end

        -- Get any missing keys entry BEFORE locking this table.
        local allowMissingKeysTableNameSet = {}
        if table._allowMissingKeys then
            for _, tableName in ipairs(table._allowMissingKeys) do
                allowMissingKeysTableNameSet[tableName] = true
            end
        end

        -- Lock the given table.
        local firstLetter = string.match(tableName, '%a')
        local isUpper = firstLetter and firstLetter == string.upper(firstLetter)
        if isUpper and not allowMissingKeys then
            CrLua.LockTable.readOnlyRequireKey(tableName, table)
        else
            CrLua.LockTable.readOnly(tableName, table)
        end

        -- Lock sub-tables, respecting _allowMissingKeys values.
        for k, v in pairs(table) do
            if type(v) == 'table' then
                local entryAllowMissingKeys = allowMissingKeys or allowMissingKeysTableNameSet[k] or false
                lockRecursive(tostring(k), v, entryAllowMissingKeys)
            end
        end
    end

    lockRecursive(tableName or 'CrLua', table or CrLua, false)
end

-- ############################################################################
-- #### END #include <~/CrLua/CrLua>
-- ############################################################################

-- ############################################################################
-- #### START #include <~/CrLua/LockGlobals>
-- ############################################################################

-------------------------------------------------------------------------------
--- Partially lock the _G global variable table.
-- Include this AFTER creating any necessary globals to prevent new ones.
--
-- - Existing globals can still be read AND WRITTEN.
-- - Cannot read non-existent globals.
-- - Cannot write new globals.
--
-- This helps catch typos where what was meant to access a local instead
-- references a (hopefully non-existent) global, as well as forgetting to use
-- "local" when creating objects.
--
-- @author Darrell
-------------------------------------------------------------------------------

local TAG = 'CrLua.LockGlobals'
local _lockGlobalsMetaTable = {}

-- Index is only called when the key does not already exist.
function _lockGlobalsMetaTable.__index(table, key)
    error(TAG .. ': accessing missing global "' .. tostring(key or '<nil>') .. '", typo?', 2)
end

function _lockGlobalsMetaTable.__newindex(table, key, value)
    error(TAG .. ': globals are locked, cannot create global variable "' .. tostring(key or '<nil>') .. '"', 2)
end

setmetatable(_G, _lockGlobalsMetaTable)

-------------------------------------------------------------------------------

-- Add a test function to the CrLua "namespace".
CrLua = CrLua or {}  -- global, <include> wraps in a do .. end block
CrLua.LockGlobals = assert(not CrLua.LockGlobals) and {
    _require = { 'LockGlobals' }  -- require self to avoid missing require error
}

-- ############################################################################
-- #### END #include <~/CrLua/LockGlobals>
-- ############################################################################

-- ############################################################################
-- #### START #include <~/CrLua/TTS/Object>
-- ############################################################################

-------------------------------------------------------------------------------
--- Tabletop Simulator helper functions.
-- Unlike the other scripts, requires the Tabletop Simulator runtime
-- (e.g., to call getSeatedPlayers).
-- @author Darrell
-------------------------------------------------------------------------------

local TAG = 'CrLua.TTS.Object'

CrLua = CrLua or {}  -- global, <include> wraps in a do .. end block
CrLua.TTS = CrLua.TTS or {}
CrLua.TTS.Object = assert(not CrLua.TTS.Object) and {
    _require = { 'List' }
}

-- ############################################################################
-- #### END #include <~/CrLua/TTS/Object>
-- ############################################################################

-- ############################################################################
-- #### START #include <~/CrLua/TTS/Player>
-- ############################################################################

-------------------------------------------------------------------------------
--- Tabletop Simulator helper functions.
-- Unlike the other scripts, requires the Tabletop Simulator runtime
-- (e.g., to call getSeatedPlayers).
-- @author Darrell
-------------------------------------------------------------------------------

local TAG = 'CrLua.TTS.Player'

CrLua = CrLua or {}  -- global, <include> wraps in a do .. end block
CrLua.TTS = CrLua.TTS or {}
CrLua.TTS.Player = assert(not CrLua.TTS.Player) and {
    _require = { 'Util' }
}

-- ############################################################################
-- #### END #include <~/CrLua/TTS/Player>
-- ############################################################################

-- ############################################################################
-- #### START #include <~/CrLua/List>
-- ############################################################################

-------------------------------------------------------------------------------
--- Lua list utility functions
-- @author Darrell
-------------------------------------------------------------------------------

local TAG = 'CrLua.List'

CrLua = CrLua or {}  -- global, <include> wraps in a do .. end block
CrLua.List = assert(not CrLua.List) and {
    _require = {}
}

-------------------------------------------------------------------------------
--- Reduce a list to unique elements.
-- @param list : table with number inidice.
-- @return list : table with number indices and unique elements.
-------------------------------------------------------------------------------
function CrLua.List.unique(list)
    local result = {}
    local seen = {}
    for _, v in ipairs(list) do
        if not seen[v] then
            seen[v] = true
            table.insert(result, v)
        end
    end
    return result
end

-- ############################################################################
-- #### END #include <~/CrLua/List>
-- ############################################################################

-- ############################################################################
-- #### START #include <~/CrLua/LockTable>
-- ############################################################################

-------------------------------------------------------------------------------
--- Access control for tables.
--
-- Locked tables are empty, using a metatable to detect and redirect all forms
-- of access to the actual table data.  Metatables contain a few custom fields:
-- - '_name' string table name.
-- - '_attrSet' table from set attribute names to true.
-- - '_tableContents' table holding the actual locked table content.
--
-- @author Darrell
-------------------------------------------------------------------------------

local TAG = 'CrLua.LockTable'

CrLua = CrLua or {}  -- global, <include> wraps in a do .. end block
CrLua.LockTable = assert(not CrLua.LockTable) and {
    _require = {}
}

CrLua.LockTable.ATTR = {
    READ_ONLY = 1,
    REQUIRE_KEY = 2
}

CrLua.LockTable.ACCESS_TYPE = {
    READ_MISSING = 'read missing',
    WRITE_NEW = 'write new',
    OVERWRITE = 'overwrite'
}

-------------------------------------------------------------------------------
--- Error and stop script when misusing a locked table.
-------------------------------------------------------------------------------
function CrLua.LockTable._error(lockedTable, key, accessType)
    assert(type(lockedTable) == 'table' and type(accessType) == 'string')
    local metatable = assert(getmetatable(lockedTable))
    local tableName = assert(metatable._name)
    local keyName = tostring(key or '<nil>')
    error(TAG .. ': ' .. accessType .. ' ' .. tableName .. '.' .. keyName)
end

-------------------------------------------------------------------------------
--- Create a new table with the lock table metamethods.
-- @param tableName string : use this as the tableName.key when reporting errors.
-- @param attrs table : list of LockTable.ATTRS to apply.
-- @param table : table to lock (this table itself is mutated!)
-- @return table : the same table, returned for create-by-wrapping convenience.
-------------------------------------------------------------------------------
function CrLua.LockTable._apply(tableName, attrs, table)
    assert(type(tableName) == 'string' and type(attrs) == 'table' and type(table) == 'table')

    -- Do not attempt to lock a table that already has a metatable.
    assert(not getmetatable(table), 'cannot apply LockTable when a metatable is already set: ' .. tableName)

    local newMetaTable = {
        _name = tableName,
        _attrSet = {},
        _tableContents = {}
    }

    -- Add the metatable methods to behave like the original table.
    for k, v in pairs(CrLua.LockTable._metatable) do
        newMetaTable[k] = v
    end

    -- Apply attrs.
    for _, attr in ipairs(attrs) do
        assert(type(attr) == 'number')
        newMetaTable._attrSet[attr] = true
    end

    -- Move table contents.
    for k, v in pairs(table) do
        newMetaTable._tableContents[k] = v
        table[k] = nil
    end

    setmetatable(table, newMetaTable)
    return table
end

CrLua.LockTable._metatable = {}

function CrLua.LockTable._metatable.__index(lockedTable, key)
    local metatable = getmetatable(lockedTable)
    local attrSet = metatable._attrSet
    local tableContents = metatable._tableContents
    local value = tableContents[key]
    local existing = value ~= nil
    if not existing and attrSet[CrLua.LockTable.ATTR.REQUIRE_KEY] then
        CrLua.LockTable._error(lockedTable, key, CrLua.LockTable.ACCESS_TYPE.READ_MISSING)
    end
    return value
end

function CrLua.LockTable._metatable.__newindex(lockedTable, key, value)
    local metatable = getmetatable(lockedTable)
    local attrSet = metatable._attrSet
    local tableContents = metatable._tableContents
    local existing = tableContents[key] ~= nil
    if attrSet[CrLua.LockTable.ATTR.READ_ONLY] then
        local accessType = existing and CrLua.LockTable.ACCESS_TYPE.OVERWRITE or CrLua.LockTable.ACCESS_TYPE.WRITE_NEW
        CrLua.LockTable._error(lockedTable, key, accessType)
    elseif not existing and attrSet[CrLua.LockTable.ATTR.REQUIRE_KEY] then
        CrLua.LockTable._error(lockedTable, key, CrLua.LockTable.ACCESS_TYPE.WRITE_NEW)
    end
    tableContents[key] = value
end

function CrLua.LockTable._metatable.__pairs(lockedTable)
    local metatable = getmetatable(lockedTable)
    local tableContents = metatable._tableContents
    local function iter(_, k)
        local k, v = next(tableContents, k)
        if v ~= nil then
            return k, v
        end
    end
    return iter, lockedTable, nil
end

function CrLua.LockTable._metatable.__ipairs(lockedTable)
    local metatable = getmetatable(lockedTable)
    local tableContents = metatable._tableContents
    local function iter(_, i)
        local v = tableContents[i + 1]
        if v ~= nil then
            return i + 1, v
        end
    end
    return iter, lockedTable, 0
end

function CrLua.LockTable._metatable.__len(lockedTable)
    local metatable = getmetatable(lockedTable)
    local tableContents = metatable._tableContents
    return #tableContents
end

-------------------------------------------------------------------------------
--- Make table read-only.
-- Reads to missing values return nil, as normal.
-- If the table has a _name entry, use that when reporting errors.
-- @param table
-- @param table : the same table as the argument for convenience assignment.
-------------------------------------------------------------------------------
function CrLua.LockTable.readOnly(tableName, table)
    assert(type(tableName) == 'string' and type(table) == 'table')
    assert(type(table) == 'table')

    local attrs = { CrLua.LockTable.ATTR.READ_ONLY }
    return CrLua.LockTable._apply(tableName, attrs, table)
end

-------------------------------------------------------------------------------
--- Make table read-only, and error if accessing missing key.
-- Helps catch typos reading from must-have-item tables.
-- @param table
-- @param table : the same table as the argument for convenience assignment.
-------------------------------------------------------------------------------
function CrLua.LockTable.readOnlyRequireKey(tableName, table)
    assert(type(tableName) == 'string' and type(table) == 'table')

    local attrs = { CrLua.LockTable.ATTR.READ_ONLY, CrLua.LockTable.ATTR.REQUIRE_KEY }
    return CrLua.LockTable._apply(tableName, attrs, table)
end

-- ############################################################################
-- #### END #include <~/CrLua/LockTable>
-- ############################################################################

-- ############################################################################
-- #### START #include <~/CrLua/Log>
-- ############################################################################

-------------------------------------------------------------------------------
--- Lua logging functions
-- @author Darrell
-------------------------------------------------------------------------------

local TAG = 'CrLua.Log'

CrLua = CrLua or {}  -- global, <include> wraps in a do .. end block
CrLua.Log = assert(not CrLua.Log) and {
    _require = {},
    _data = {}
}

CrLua.Log.LOG_LEVEL = {
    DEBUG = { level = 1, shortString = 'd' },
    INFO = { level = 2, shortString = 'i' },
    WARNING = { level = 3, shortString = 'w' },
	ERROR = { level = 4, shortString = 'e' },
    NONE = { level = 5, shortString = 'x' },
}

-- Store mutable level in a nested table to avoid mutating anything in Log.
CrLua.Log._data.level = CrLua.Log.LOG_LEVEL.NONE

-------------------------------------------------------------------------------
--- Set the log level, only log messagees at this level and above.
-- @param level table : CrLua.Log.LOG_LEVEL value.
-------------------------------------------------------------------------------
function CrLua.Log.setLogLevel(level)
    assert(level and type(level.level) == 'number' and type(level.shortString) == 'string')
    CrLua.Log._data.level = level
end

function CrLua.Log._logTable(message, table, depth)
    assert(type(message) == 'string' and type(table) == 'table' and type(depth) == 'number')

    local indent = '   '
    local prefix = ''
    if depth > 1 then
        for i = 2, depth do
            prefix = prefix .. indent
        end
    end
    local indentedPrefix = prefix .. '   '

    print(prefix .. message .. ' = {')
    if depth < 4 then
        for k, v in pairs(table) do
            if type(v) == 'table' then
                CrLua.Log._logTable(tostring(k), v, depth + 1)
            else
                print(indentedPrefix .. tostring(k) .. ' = ' .. tostring(v))
            end
        end
    else
        -- Stop once too deep (also prevents infinite loops if cycles).
        print(indentedPrefix .. '...')
    end
    print(prefix .. '}')
end

function CrLua.Log._log(logLevel, tag, message, table)
    -- Be verbose about bad arguments here, easy to pass the wrong item.
    -- ALWAYS verify arguments even if log level will suppress logging,
    -- otherwise bugs can creep in that only tickle when logging is enabled.
    if type(tag) ~= 'string' then
        error(TAG .. '_log: tag is not a string', 2)
    elseif type(message) ~= 'string' then
        error(TAG .. '_log: message is not a string', 2)
    elseif table and type(table) ~= 'table' then
        error(TAG .. '_log: table is not a table', 2)
    end

    if logLevel.level < CrLua.Log._data.level.level then
        return
    end

    -- Insert the tag as message prefix.
    message = tag .. ' ' .. message

    -- Inject a [timestamp/level] prefix.
    local timestamp = os.date('%I:%M.%S')
    message = '[' .. timestamp .. '/' .. logLevel.shortString .. '] ' .. message

    if table then
        CrLua.Log._logTable(message, table, 1)
    else
        print(message)
    end
end

-------------------------------------------------------------------------------
--- Log a debug message.
-- @param tag string.
-- @param message string.
-- @table optional table, logging contents if given.
-------------------------------------------------------------------------------
function CrLua.Log.d(tag, message, table)
    CrLua.Log._log(CrLua.Log.LOG_LEVEL.DEBUG, tag, message, table)
end

-- ############################################################################
-- #### END #include <~/CrLua/Log>
-- ############################################################################

-- ############################################################################
-- #### START #include <~/CrLua/Util>
-- ############################################################################

-------------------------------------------------------------------------------
--- Lua utility functions
-- @author Darrell
-------------------------------------------------------------------------------

local TAG = 'CrLua.Util'

CrLua = CrLua or {}  -- global, <include> wraps in a do .. end block
CrLua.Util = assert(not CrLua.Util) and {
    _require = {}
}

-------------------------------------------------------------------------------
--- Compute the distance between two {x,y,z} vectors.
-- @param a table : {x,y,z} keys.
-- @param b table : {x,y,z} keys.
-- @return distance squared (sqrt it if need exact, sq is fine for sorting).
-------------------------------------------------------------------------------
function CrLua.Util.distanceSq(a, b)
    local dx = a.x - b.x
    local dy = a.y - b.y
    local dz = a.z - b.z
    return (dx * dx) + (dy * dy) + (dz * dz)
end

-------------------------------------------------------------------------------
--- Find the minimum value in a table, with optional function for value.
-- @param table : table with arbitrary keys (may be a list).
-- @param optional minFunction : call for each value to minimize.
-- @return ? : table value with the min value.
-- Function can return false/nil to reject value from consideration.
-------------------------------------------------------------------------------
function CrLua.Util.min(table, minFunction)
    assert(type(table) == 'table' and ((not minFunction) or type(minFunction) == 'function'))

    local minScore = nil
    local minKey, minValue = nil, nil
    for k, v in pairs(table) do
        local score = (minFunction and minFunction(v)) or tonumber(v)
        if score and (not minScore or score < minScore) then
            minScore = score
            minKey = k
            minValue = v
        end
    end
    return minKey, minValue
end

-- ############################################################################
-- #### END #include <~/CrLua/Util>
-- ############################################################################

--CrLua.Log.setLogLevel(CrLua.Log.LOG_LEVEL.DEBUG)
--#include <~/CrLua/UnitTest>
--CrLua.UnitTest.runTests(TAG, CrLua, true)

CrLua.assertRequired({
    'TTS.Object',
    'TTS.Player',
    'List',
    'Log' })
CrLua.lock()

-- ############################################################################
-- #### END #include <~/CrLua/Objects/AutoFillMultiRoller>
-- ############################################################################