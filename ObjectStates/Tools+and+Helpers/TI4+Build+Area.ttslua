-- ############################################################################
-- #### START #include <~/CrLua/Objects/TI4_BuildArea>
-- ############################################################################

--- Show the produce and consume costs for contained objects.
-- @author Darrell

local TAG = 'BuildArea'

local BASE_PRODUCTION = 2

local OBJECT_EFFECTS = {
    -- Tokens
    ['x1 Commodities/Tradegoods'] = {
        tradegoods = true,
        resources = 1,
    },
    ['x3 Commodities/Tradegoods'] = {
        tradegoods = true,
        resources = 3,
    },

    -- Technologies
    ['Sarween Tools'] = {
        anywhereInPlayerZone = true,
        requireFaceUp = true,
        sarween = true,
    },
    ['Mirror Computing'] = {
        anywhereInPlayerZone = true,
        requireFaceUp = true,
        objectEffectsOverrides = {
            ['x1 Commodities/Tradegoods'] = {
                resources = 2,
            },
            ['x3 Commodities/Tradegoods'] = {
                resources = 6,
            },
        },
    },
    ['Hegemonic Trade Policy'] = {
        requireFaceUp = true,
        hegemonic = true,
    },

    -- Actions
    ['War Machine (1)'] = {
        anywhereInPlayerZone = true,
        requireFaceUp = true,
        warmachine = true,
    },
    ['War Machine (2)'] = {
        anywhereInPlayerZone = true,
        requireFaceUp = true,
        warmachine = true,
    },
    ['War Machine (3)'] = {
        anywhereInPlayerZone = true,
        requireFaceUp = true,
        warmachine = true,
    },
    ['War Machine (4)'] = {
        anywhereInPlayerZone = true,
        requireFaceUp = true,
        warmachine = true,
    },
}

-------------------------------------------------------------------------------

local _config = {
    defaultWidth = 8.37,
    defaultHeight = 5,
    minWidth = 8.37,
    minHeight = 5,
    thickness = 0.3,
}

local _data = {
    playerColor = 'Grey',
    width = _config.defaultWidth,
    height = _config.defaultHeight,

    boundingBox = false,
    lowerNameToResources = false,

    inside = {},

    dragOffset = {
        x = 0,
        z = 0
    },

    philModeProductionValue = false
}

local _deckHelper = false
local _factionHelper = false
local _systemHelper = false
local _unitHelper = false
local _zoneHelper = false

local _graveyardGuid = false

local _unitAttributes = false
local _unitAttributesLastUpdateTime = false

-------------------------------------------------------------------------------

function onLoad(saveState)
    CrLua.Log.d(TAG, 'onLoad')
    math.randomseed(tonumber(self.getGUID(), 16))

    local saveState = saveState and JSON.decode(saveState)
    _data.width = saveState and saveState.width or _data.width
    _data.height = saveState and saveState.height or _data.height
    _data.width = math.max(_data.width, _config.minWidth)
    _data.height = math.max(_data.height, _config.minHeight)
    _data.playerColor = saveState and saveState.playerColor or _data.playerColor

    _deckHelper = CrLua.TTS.HelperClient.get('TI4_DECK_HELPER')
    _factionHelper = CrLua.TTS.HelperClient.get('TI4_FACTION_HELPER')
    _systemHelper = CrLua.TTS.HelperClient.get('TI4_SYSTEM_HELPER')
    _unitHelper = CrLua.TTS.HelperClient.get('TI4_UNIT_HELPER')
    _zoneHelper = CrLua.TTS.HelperClient.get('TI4_ZONE_HELPER')

    self.addContextMenuItem("Warp to active", warpToActiveSystem, false)
    self.addContextMenuItem("Warp to home", warpToHomeSystem, false)
    self.addContextMenuItem("Trash trade goods", trashTradeGoods, false)
    self.addContextMenuItem("Toggle Phil Mode", togglePhilMode)

    Wait.frames(updateEverything, 2)
end

function onSave()
    return JSON.encode({
        width = _data.width,
        height = _data.height,
        playerColor = _data.playerColor,
    })
end

function onObjectDrop(playerColor, droppedObject)
    assert(type(playerColor) == 'string' and type(droppedObject) == 'userdata')
    if droppedObject == self then
        CrLua.Log.d(TAG, 'onObjectDrop: self')
        _graveyardGuid = false
        updateEverything()
    elseif isInsideBuildArea(droppedObject.getPosition()) then
        _data.inside[droppedObject] = true
        updateProduceConsumeValues()
    end
end

function onObjectPickUp(playerColor, pickedUpObject)
    assert(type(playerColor) == 'string' and type(pickedUpObject) == 'userdata')
    if pickedUpObject == self then
        CrLua.Log.d(TAG, 'onObjectPickUp: self')
    elseif _data.inside[pickedUpObject] then
        _data.inside[pickedUpObject] = nil
        updateProduceConsumeValues()
    end
end

function onPlayerChangeColor(playerColor)
    CrLua.Log.d(TAG, 'onPlayerChangeColor')
    Wait.frames(updateEverything, 2)
end

function onObjectDestroy(dyingObject)
    if _data.inside[dyingObject] then
        _data.inside[dyingObject] = nil
        updateEverything()
    end
end

function onObjectSpawn(object)
    local guid = object.getGUID()

    local function delayedCheckSpawn()
        local object = getObjectFromGUID(guid)
        if object and (not _data.inside[object]) and isInsideBuildArea(object.getPosition()) then
            _data.inside[object] = true
            updateProduceConsumeValues()
        end
    end

    -- Often objects are drawn from a bag with a mouse points, and will be
    -- "held by color" at spawn time with a certain "on object drop" detected
    -- above.  Some scripts can create objects (e.g. numpad spawn, or swapping
    -- tokens and plastic).  In those cases, check up on those objects after
    -- a few seconds to see if they landed in zone.
    local name = object.getName()
    if (not object.held_by_color) and string.len(name) > 0 then
        if OBJECT_EFFECTS[name] or _unitHelper.isUnitName(name) then
            Wait.time(delayedCheckSpawn, 2.5 + math.random())
        end
    end
end

-------------------------------------------------------------------------------

function _getUnitAttributes(unitType)
    assert(type(unitType) == 'string')
    if _unitAttributes and (_unitAttributesLastUpdateTime or 0) > (Time.time - 15) then
        return _unitAttributes[unitType]
    end

    local color = getPlayerColor()

    local unitOverrides = _unitHelper.getColorToUnitOverrides()[color] or {}
    local unitModifiers = _unitHelper.getColorToUnitModifiers()[color] or {}

    -- Apply unit overrides.
    local unitAttrs = _unitHelper.getUnitAttributes(unitOverrides)

    -- Apply unit modifiers.
    unitAttrs = _unitHelper.applyUnitModifiers({
        unitAttrs = assert(unitAttrs),
        myColor = color or 'Grey',
        myUnitModifiers = unitModifiers,
        myUnitTypeToCount = {},
        opponentColor = false,
        opponentUnitModifiers = false,
        opponentUnitTypeToCount = false
    })

    _unitAttributes = unitAttrs
    _unitAttributesLastUpdateTime = Time.time
    return _unitAttributes[unitType]
end

function _getProduction()
    local spaceDock = _getUnitAttributes('Space Dock')
    local production = (spaceDock and spaceDock.production) or 0
    if production < 0 then
        return 'R+' .. (-production)
    end
    return '' .. production
end

--- Get UnitHelper units {guid, unitType, count}.
function _getUnitsInsideBuildArea()
    local units = {}
    for _, unit in ipairs(_unitHelper.getUnits()) do
        if isInsideBuildArea(unit.position) then
            local unitObject = getObjectFromGUID(unit.guid)
            if unitObject and not unitObject.held_by_color then
                table.insert(units, unit)
            end
        end
    end
    return units
end

local function _warpToSystem(system)
    assert(type(system) == 'table')
    print(TAG .. ': warping to ' .. system.string)

    local systemObject = getObjectFromGUID(system.guid)
    if not systemObject then
        error('missing system guid ' .. system.guid)
    end

    local unitObjects = {}
    for _, unit in ipairs(_getUnitsInsideBuildArea()) do
        local unitObject = getObjectFromGUID(unit.guid)
        if unitObject then
            table.insert(unitObjects, unitObject)
        end
    end

    local p0 = systemObject.getPosition()
    for i, unitObject in ipairs(unitObjects) do
        _data.inside[unitObject] = nil
        local phi = math.rad(i * (360 / #unitObjects))
        local r = 2
        local collide = false
        local fast = true
        unitObject.setPositionSmooth({
            x = p0.x + r * math.cos(phi),
            y = p0.y + 3,
            z = p0.z + r * math.sin(phi)
        }, collide, fast)
    end
end

function warpToActiveSystem()
    local system = _systemHelper.getActivatedSystem()
    if system then
        _warpToSystem(system)
    else
        print(TAG .. ': no active system.')
    end
    Wait.time(updateProduceConsumeValues, 1)
    Wait.time(updateProduceConsumeValues, 3)  -- again, in case warp was slow
end

function warpToHomeSystem()
    local zoneColor = _zoneHelper.zoneFromPosition(self.getPosition())
    local faction = zoneColor and _factionHelper.fromColor(zoneColor)
    local tile = faction and faction.home
    local system = _systemHelper.systemFromTile(tile)
    if system then
        _warpToSystem(system)
    else
        print(TAG .. ': no home system.')
    end
    Wait.time(updateProduceConsumeValues, 1)
    Wait.time(updateProduceConsumeValues, 3)  -- again, in case warp was slow
end

function trashTradeGoods()
    local function getGraveyard()
        local graveyard = _graveyardGuid and getObjectFromGUID(_graveyardGuid)
        if graveyard then
            return graveyard
        end
        local bestGraveyard = false
        local bestDistanceSq = false
        local p1 = self.getPosition()
        for _, object in ipairs(getAllObjects()) do
            if object.tag == 'Bag' and string.match(object.getName(), '^TI4 Graveyard') then
                local p2 = object.getPosition()
                local dSq = (p1.x - p2.x) ^ 2 + (p1.z - p2.z) ^ 2
                if not bestDistanceSq or dSq < bestDistanceSq then
                    bestGraveyard = object
                    bestDistanceSq = dSq
                end
            end
        end
        _graveyardGuid = bestGraveyard and bestGraveyard.getGUID()
        return bestGraveyard
    end

    local tradeGoods = {}
    for object, _ in pairs(_data.inside) do
        if string.match(object.getName(), 'x[13] Commodities/Tradegoods') then
            table.insert(tradeGoods, object)
        end
    end

    local graveyard = getGraveyard()
    if graveyard then
        for _, tradeGood in ipairs(tradeGoods) do
            _data.inside[tradeGood] = nil
            graveyard.putObject(tradeGood)
        end
    end
    updateProduceConsumeValues()
end

function togglePhilMode()
    if _data.philModeProductionValue then
        _data.philModeProductionValue = false
    else
        _data.philModeProductionValue = 4
    end
    drawBoundingBox()
    updateProduceConsumeValues()
end

-------------------------------------------------------------------------------

function onButtonClick(player, option, id)
    announce(_data.items, _data.resourcesAndCost)
    commit()
end

function onInputValueChanged(player, value, id)
    if id == 'philModeProductionValue' then
        _data.philModeProductionValue = tonumber(value)
        drawBoundingBox()
    else
        error('unknown input ' .. id)
    end
end

function onBeginDrag(player, option, id)
    local pp = self.positionToLocal(player.getPointerPosition())
    _data.dragOffset = {
        x = _data.width - pp.x,
        z = _data.height - pp.z
    }
end

function onEndDrag(player, option, id)
    local pp = self.positionToLocal(player.getPointerPosition())
    _data.width = pp.x + _data.dragOffset.x
    _data.height = pp.z + _data.dragOffset.z
    _data.width = math.max(_data.width, _config.minWidth)
    _data.height = math.max(_data.height, _config.minHeight)
    updateEverything()
end

function onDrag(player, option, id)
    local pp = self.positionToLocal(player.getPointerPosition())
    _data.width = pp.x + _data.dragOffset.x
    _data.height = pp.z + _data.dragOffset.z
    _data.width = math.max(_data.width, _config.minWidth)
    _data.height = math.max(_data.height, _config.minHeight)
    updateBoundingBox()
end

-------------------------------------------------------------------------------

function updateEverything()
    updatePlayerColor()
    updateBoundingBox()
    updateInsideBuildArea()
    updateProduceConsumeValues()
end

function updatePlayerColor()
    _data.playerColor = getPlayerColor() or 'Grey'
    self.setColorTint(_data.playerColor)
end

function updateBoundingBox()
    _data.boundingBox = getLocalBoundingBox()
    drawBoundingBox()
end

function updateInsideBuildArea()
    _data.inside = {}
    for _, object in ipairs(getAllObjects()) do
        if isInsideBuildArea(object.getPosition()) then
            _data.inside[object] = true
        end
    end
end

function updateProduceConsumeValues()
    _data.items = getProduceConsumeItems()
    _data.resourcesAndCost = getProduceConsumeResourcesAndCost(_data.items)
    drawUi(_data.items, _data.resourcesAndCost)
end

-------------------------------------------------------------------------------

function getLocalBoundingBox()
    local bounds = self.getBoundsNormalized()
    local scale = self.getScale()
    local min = {
        x = -bounds.size.x / 2.0 / scale.x,
        y = -bounds.size.y / 2.0,
        z = -bounds.size.z / 2.0 / scale.z
    }
    local max = {
        x = min.x + _data.width,
        y = bounds.size.y / 2.0,
        z = min.z + _data.height
    }
    return {
        min = min,
        max = max
    }
end

function isInsideBuildArea(position)
    assert(type(position) == 'table')
    local p = self.positionToLocal(position)
    local bb = _data.boundingBox
    return bb.min.x <= p.x and p.x <= bb.max.x and bb.min.z <= p.z and p.z <= bb.max.z
end

function getResourcesAndInfluence(objectName)
    assert(type(objectName) == 'string')
    if not _data.lowerNameToResources then
        _data.lowerNameToResources = {}
        for lowerName, planet in pairs(_systemHelper.planets()) do
            _data.lowerNameToResources[lowerName] = {
                resources = planet.resources or 0,
                influence = planet.influence or 0
            }
        end
        for lowerName, other in pairs(_systemHelper.nonPlanetResourceInfluenceCards()) do
            _data.lowerNameToResources[lowerName] = {
                resources = other.resources or 0,
                influence = other.influence or 0
            }
        end
    end
    return _data.lowerNameToResources[string.lower(objectName)]
end

function getPlayerColor()
    local zoneColor = _zoneHelper.zoneFromPosition(self.getPosition())
    CrLua.Log.d(TAG, 'getPlayerColor: ' ..(zoneColor or 'nil'))
    return zoneColor
end

function getProduceConsumeItems()
    CrLua.Log.d(TAG, 'getProduceConsumeItems')
    local playerColor = _data.playerColor

    -- Get objects to consider.
    local inHandGuidSet = _zoneHelper.inHand()
    local objects = CrLua.Table.join(_data.inside, {})
    local function useOutsizeBuildAreaObject(object)
        local objectEffects = OBJECT_EFFECTS[object.getName()]
        if not objectEffects then
            return false
        end
        if inHandGuidSet[object.getGUID()] then
            return false
        end
        if objectEffects.requireFaceUp and object.is_face_down then
            return false
        end
        if object.tag == 'Card' and _deckHelper.isDiscard(object.getGUID()) then
            return false
        end
        if objectEffects.anywhereInPlayerZone then
            return playerColor and _zoneHelper.zoneFromPosition(object.getPosition()) == playerColor
        end
        return objectEffects.anywhereOnTable
    end
    for _, object in ipairs(getAllObjects()) do
        if useOutsizeBuildAreaObject(object) then
            objects[object] = true
        end
    end

    local result = {
        consumeObjectNameToCount = {},
        produceUnitNameToUnitWithCount = {},
        objectEffectsOverrides = {},
        sarween = false,
        hegemonic = false,
        warmachine = false,
    }

    for _, unit in ipairs(_getUnitsInsideBuildArea()) do
        if result.produceUnitNameToUnitWithCount[unit.unitType] then
            unit.count = unit.count + result.produceUnitNameToUnitWithCount[unit.unitType].count
        end
        result.produceUnitNameToUnitWithCount[unit.unitType] = unit
    end

    local function addItem(name)
        local resourcesAndInfluence = getResourcesAndInfluence(name)
        if resourcesAndInfluence then
            result.consumeObjectNameToCount[name] = (result.consumeObjectNameToCount[name] or 0) + 1
        end
        local objectEffects = OBJECT_EFFECTS[name]
        if objectEffects then
            if objectEffects.resources then
                result.consumeObjectNameToCount[name] = (result.consumeObjectNameToCount[name] or 0) + 1
            end
            if objectEffects.objectEffectsOverrides then
                result.objectEffectsOverrides = CrLua.Table.join(result.objectEffectsOverrides, objectEffects.objectEffectsOverrides)
            end
            result.sarween = result.sarween or objectEffects.sarween
            result.hegemonic = result.hegemonic or objectEffects.hegemonic
            result.warmachine = result.warmachine or objectEffects.warmachine
        end
    end

    for object, _ in pairs(objects) do
        if object.tag == 'Deck' then
            for _, entry in ipairs(object.getObjects()) do
                addItem(entry.name)
            end
        else
            addItem(object.getName())
        end
    end

    CrLua.Log.d(TAG, 'getProduceConsumeItems', result)
    return result
end

function getProduceConsumeResourcesAndCost(produceConsumeItems)
    assert(type(produceConsumeItems) == 'table')
    CrLua.Log.d(TAG, 'getProduceConsumeResourcesAndCost')

    local result = {
        resources = 0,
        cost = 0,
        numUnits = 0,
    }

    for objectName, count in pairs(produceConsumeItems.consumeObjectNameToCount) do
        local objectEffects = OBJECT_EFFECTS[objectName]
        local objectEffectsOverrides = produceConsumeItems.objectEffectsOverrides[objectName]
        objectEffects = CrLua.Table.join(objectEffects or {}, objectEffectsOverrides or {})
        if objectEffects.resources then
            result.resources = result.resources + objectEffects.resources * count
        end

        local resourcesAndInfluence = getResourcesAndInfluence(objectName)
        if resourcesAndInfluence and resourcesAndInfluence.resources then
            result.resources = result.resources + resourcesAndInfluence.resources * count
        end
    end

    for unitType, unit in pairs(produceConsumeItems.produceUnitNameToUnitWithCount) do
        local unitAttrs = _getUnitAttributes(unit.unitType)
        result.cost = result.cost + math.ceil(unit.count * (unitAttrs.cost or 0))
        result.numUnits = result.numUnits + unit.count
    end

    -- If Hegemonic Trade Policy (swap resouce/influence values), replace
    -- hegemonic with the chosen planet.
    if produceConsumeItems.hegemonic then
        local best = false
        for objectName, _ in pairs(produceConsumeItems.consumeObjectNameToCount) do
            local resourcesAndInfluence = getResourcesAndInfluence(objectName)
            local useThis = true
            useThis = useThis and resourcesAndInfluence
            useThis = useThis and resourcesAndInfluence.influence > resourcesAndInfluence.resources
            useThis = useThis and (not best or resourcesAndInfluence.influence > best.influence)
            if useThis then
                best = resourcesAndInfluence
            end
        end
        if best then
            CrLua.Log.d(TAG, 'hegemonic')
            result.resources = result.resources - best.resources
            result.resources = result.resources + best.influence
        end
    end

    CrLua.Log.d(TAG, 'getProduceConsumeResourcesAndCost', result)
    return result
end

-------------------------------------------------------------------------------

function drawBoundingBox()
    local bb = _data.boundingBox
    local d = _config.thickness / 2.0
    local y = bb.max.y - 0.01
    local lines = {{
        points = {
            { x = bb.min.x + d, y = y, z = bb.min.z + d },
            { x = bb.min.x + d, y = y, z = bb.max.z - d },
            { x = bb.max.x - d, y = y, z = bb.max.z - d },
            { x = bb.max.x - d, y = y, z = bb.min.z + d },
        },
        color = _data.playerColor,
        rotation = { x = 0, y = 0, z = 0 },
        thickness = _config.thickness,
        loop = true,
        square = true,
    }}

    if _data.philModeProductionValue and _data.philModeProductionValue > 0 then
        local x0 = bb.min.x + self.getBoundsNormalized().size.x
        local z0 = bb.min.z

        -- Draw planet area separator.
        table.insert(lines, {
            points = {
                { x = x0, y = y, z = bb.min.z },
                { x = x0, y = y, z = bb.max.z },
            },
            color = _data.playerColor,
            rotation = { x = 0, y = 0, z = 0 },
            thickness = _config.thickness,
            loop = false,
            square = true,
        })

        -- Divide remaining area into N boxes.
        local numCols = math.floor(math.sqrt(_data.philModeProductionValue))
        local numRows = math.ceil(_data.philModeProductionValue / numCols)

        local w = bb.max.x - x0
        local h = bb.max.z - z0

        local dx = w / math.max(numCols, 1)
        for col = 1, numCols - 1 do
            local x = x0 + col * dx
            table.insert(lines, {
                points = {
                    { x = x, y = y, z = bb.min.z },
                    { x = x, y = y, z = bb.max.z },
                },
                color = _data.playerColor,
                rotation = { x = 0, y = 0, z = 0 },
                thickness = _config.thickness,
                loop = false,
                square = true,
            })
        end

        local dz = h / math.max(numRows, 1)
        for row = 1, numRows - 1 do
            local z = z0 + row * dz
            table.insert(lines, {
                points = {
                    { x = x0, y = y, z = z },
                    { x = bb.max.x, y = y, z = z },
                },
                color = _data.playerColor,
                rotation = { x = 0, y = 0, z = 0 },
                thickness = _config.thickness,
                loop = false,
                square = true,
            })
        end

        local d = math.min(dx, dz) * 0.2
        for col = 1, numCols - 1 do
            local x = x0 + (col + 0.5) * dx
            for row = 1, numRows - 1 do
                local z = z0 + (row + 0.5) * dz
                if row * numCols + col >= _data.philModeProductionValue then
                    table.insert(lines, {
                        points = {
                            { x = x - d, y = y, z = z - d },
                            { x = x + d, y = y, z = z + d},
                        },
                        color = _data.playerColor,
                        rotation = { x = 0, y = 0, z = 0 },
                        thickness = _config.thickness,
                        loop = false,
                        square = true,
                    })
                    table.insert(lines, {
                        points = {
                            { x = x + d, y = y, z = z - d },
                            { x = x - d, y = y, z = z + d},
                        },
                        color = _data.playerColor,
                        rotation = { x = 0, y = 0, z = 0 },
                        thickness = _config.thickness,
                        loop = false,
                        square = true,
                    })
                end
            end
        end

    end

    self.setVectorLines(lines)
end

function drawUi(items, resourcesAndCost)
    assert(type(items) == 'table' and type(resourcesAndCost) == 'table')
    CrLua.Log.d(TAG, 'drawUi')
    assert(type(_data.playerColor) == 'string')
    local colorTable = Color.fromString(_data.playerColor)
    local hexColor = '#' .. Color.toHex(colorTable)

    local function trimFloat(value)
        return math.floor(value * 1000.0) / 1000.0
    end

    -- Text panel size.
    local bounds = self.getBoundsNormalized()
    local boundsWidth = bounds.size.x
    local boundsHeight = bounds.size.z
    local boundsDepth = bounds.size.y  -- do not scale?
    local panelWidth = bounds.size.x - _config.thickness
    local panelHeight = bounds.size.z - _config.thickness

    -- Apply inverse scale.
    local scale = self.getScale()
    boundsWidth = boundsWidth / scale.x
    boundsHeight = boundsHeight / scale.z
    panelWidth = panelWidth / scale.x
    panelHeight = panelHeight / scale.z
    bounds = nil

    -- Draggable corner.
    local cornerWidth = 0.75
    local cornerHeight = cornerWidth
    local cornerX = _data.width - (boundsWidth / 2.0) - (cornerWidth / 2.0)
    local cornerY = _data.height - (boundsHeight / 2.0) - (cornerHeight / 2.0)

    -- UI uses x100 units.
    panelWidth = panelWidth * 100
    panelHeight = panelHeight * 100
    cornerWidth = cornerWidth * 100
    cornerHeight = cornerHeight * 100
    cornerX = cornerX * 100
    cornerY = cornerY * 100
    local panelPosition = '0 0 ' .. trimFloat(boundsDepth * 50.0 + 2)
    local cornerPosition = trimFloat(cornerX) .. ' ' .. trimFloat(cornerY) .. ' ' .. trimFloat(-boundsDepth * 50.0 + 1)

    local r1c1 = 'Build Cost: ' .. (resourcesAndCost and resourcesAndCost.cost or '-')
    if resourcesAndCost and items and items.sarween then
        r1c1 = r1c1 .. '-ST'
    end
    if resourcesAndCost and items and items.warmachine then
        r1c1 = r1c1 .. '-WM'
    end
    local r2c1 = 'Resources: ' .. (resourcesAndCost and resourcesAndCost.resources or '-')
    local r1c2 = '# Units: ' .. (resourcesAndCost and resourcesAndCost.numUnits or '-')
    local r2c2 = 'Production: ' .. _getProduction()
    if items and items.warmachine then
        r2c2 = r2c2 .. '+WM'
    end

    local w = panelWidth - 30
    local w1 = w * 0.45
    local w2 = w - (2 * w1)
    local fontSize = 40

    local columnWidths = trimFloat(w1) .. ' ' .. trimFloat(w1) .. ' ' .. trimFloat(w2)

    self.UI.setXmlTable({
        {
            tag = 'Defaults',
            children = {
                {
                    tag = 'Text',
                    attributes = {
                        color = '#ffffff',
                        fontSize = fontSize,
                        fontStyle = 'Bold',
                        alignment = 'MiddleCenter',
                        horizontalOverflow = 'Overflow',
                        verticalOverflow = 'Overflow',
                    }
                },
                {
                    tag = 'Button',
                    attributes = {
                        fontSize = fontSize,
                        fontStyle = 'Bold',
                        onClick = 'onButtonClick',
                    }
                },
            }
        },
        {
            tag = 'Panel',
            attributes = {
                position = panelPosition,
                rotation = '180 0 0',
                width = panelWidth,
                height = panelHeight,
                color = '#222222ff'
            },
            children = {
                {
                    tag = 'TableLayout',
                    attributes = {
                        cellBackgroundColor = 'Clear',
                        padding = '15 15 15 15',
                        columnWidths = columnWidths,
                    },
                    children = {
                        {
                            tag = 'Row',
                            children = {
                                { tag = 'Cell', children = {{
                                    tag = 'Text',
                                    value = r1c1
                                }}},
                                { tag = 'Cell', children = {{
                                    tag = 'Text',
                                    value = r1c2
                                }}},
                                { tag = 'Cell', children = {{
                                    tag = 'Button',
                                    attributes = {
                                        id = 'done',
                                        height = panelHeight,
                                    },
                                    value = '\u{25BA}'
                                }}},
                            }
                        },
                        {
                            tag = 'Row',
                            children = {
                                { tag = 'Cell', children = {{
                                    tag = 'Text',
                                    value = r2c1
                                }}},
                                { tag = 'Cell', children = {{
                                    tag = 'Text',
                                    value = r2c2
                                }}},
                                { tag = 'Cell', children = {{
                                    tag = 'InputField',
                                    attributes = {
                                        active = _data.philModeProductionValue and true or false,
                                        id = 'philModeProductionValue',
                                        onValueChanged = 'onInputValueChanged',
                                        characterValidation = 'Integer',
                                        characterLimit = 2,
                                        fontSize = fontSize * 0.9,
                                        fontStyle = 'Bold',
                                        horizontalOverflow = 'Overflow',
                                        verticalOverflow = 'Overflow',
                                        text = _data.philModeProductionValue or 4
                                    },
                                }}},
                            }
                        }
                    }
                }
            }
        },
        {
            tag = 'Panel',
            attributes = {
                id = 'corner',
                allowDragging = true,
                restrictDraggingToParentBounds = false,
                returnToOriginalPositionWhenReleased = false,
                onDrag = 'onDrag',
                onBeginDrag = 'onBeginDrag',
                onEndDrag = 'onEndDrag',
                position = cornerPosition,
                rotation = '180 0 0',
                width = cornerWidth,
                height = cornerHeight,
                color = hexColor
            },
        }
    })
end

-------------------------------------------------------------------------------

function announce(items, resourcesAndCost)
    assert(type(items) == 'table' and type(resourcesAndCost) == 'table')
    CrLua.Log.d(TAG, 'announce')
    local produce = {}
    for unitType, unit in pairs(items.produceUnitNameToUnitWithCount) do
        if unit.count > 1 then
            if unitType ~= 'Infantry' then
                unitType = unitType .. 's'
            end
        end
        table.insert(produce, unit.count .. ' ' .. unitType)
    end

    local tradegoods = 0
    local consume = {}
    for objectName, count in pairs(items.consumeObjectNameToCount) do
        local objectEffects = OBJECT_EFFECTS[objectName]
        local objectEffectsOverrides = items.objectEffectsOverrides[objectName]
        objectEffects = CrLua.Table.join(objectEffects or {}, objectEffectsOverrides or {})
        if objectEffects.tradegoods then
            tradegoods = tradegoods + (objectEffects.resources * count)
        else
            table.insert(consume, objectName)
        end
    end
    if tradegoods > 0 then
        table.insert(consume, tradegoods .. ' tradegood' .. (tradegoods > 1 and 's' or ''))
    end

    local message = table.concat({
        _data.playerColor,
        ' producing ' .. resourcesAndCost.numUnits .. ' units',
        ' { ' .. table.concat(produce, ', ') .. ' }',
        ' with production ' .. _getProduction(),
        items.warmachine and '+WM' or '',
        ' and total cost ' .. resourcesAndCost.cost,
        items.sarween and '-ST' or '',
        items.warmachine and '-WM' or '',
        ',',
        ' consuming ' .. resourcesAndCost.resources,
        ' resources',
        ' { ' .. table.concat(consume, ', ') .. ' }',
        '.',
    }, '')
    printToAll(message, _data.playerColor)
end

function commit()
    CrLua.Log.d(TAG, 'commit')
    for object, _ in pairs(_data.inside) do
        if (object.tag == 'Card' or object.tag == 'Deck') and not object.is_face_down then
            object.flip()
        end
    end
end

-------------------------------------------------------------------------------

-- ############################################################################
-- #### START #include <~/CrLua/CrLua>
-- ############################################################################

-------------------------------------------------------------------------------
--- Create the base CrLua table, with require function for dependencies.
-- @author Darrell
--
-- Suggested use: at the END of the object script (so #include does not affect
-- line number reporting in the above portion), include CrLua and dependencies:
--
-- #include <~/CrLua/CrLua>
-- #include <~/CrLua/LockGlobals>
--
-- #include <~/CrLua/[OTHER_DEPENDENCY]> (repeat)
--
-- CrLua.assertRequired() -- do this BEFORE lock
-- CrLua.lock()
--
-- -- Optionally enable logging.
-- CrLua.Log.setLogLevel(CrLua.Log.LOG_LEVEL.DEBUG)
-------------------------------------------------------------------------------

local TAG = 'CrLua'

-- Create a GLOBAL CrLua table.
CrLua = CrLua or {}  -- global, <include> wraps in a do .. end block
CrLua._require = { 'LockTable' }

-------------------------------------------------------------------------------
--- Assert all required packages exist.
-- @param extraRequires table : list of additional require entries.
-- @param table : table to search for _require entries, or CrLua if nil.
--
-- Modules add dependencies by having a _require item in their root table,
-- with a list of module names.
-- e.g. CrLua.MyModule = { _require = { 'OtherModule1', 'OtherModule2' } }.
-------------------------------------------------------------------------------
function CrLua.assertRequired(extraRequires, table)
    local seen = {}
    local requireSet = {}
    local haveSet = {}

    if extraRequires then
        for _, name in ipairs(extraRequires) do
            requireSet[name] = true
        end
    end

    local function addRequireEntries(table, packagePath)
        assert(type(table) == 'table')
        if seen[table] then
            return
        end
        seen[table] = true
        if table._require then
            for _, name in ipairs(table._require) do
                requireSet[name] = true
            end
            if packagePath then
                haveSet[packagePath] = true
            end
        end
        for k, v in pairs(table) do
            if type(v) == 'table' and not string.match(k, '^[_%l]') then
                local recurse = type(k) == 'string' and string.match(k, '^%u')
                if recurse then
                    local childPackagePath = (packagePath and (packagePath .. '.') or '') .. k
                    addRequireEntries(v, childPackagePath)
                end
            end
        end
    end
    addRequireEntries(table or CrLua)

    -- Make sure all required packages are present.
    local message = false
    for package, _ in pairs(requireSet) do
        assert(type(package) == 'string')
        -- Descend dot-delimited sub-package names.
        local entry = CrLua
        for subPackage in string.gmatch(package, '[^%.]+') do
            entry = entry and entry[subPackage]
        end
        if not entry then
            message = (message and message .. ', ' or '') .. package
        end
    end
    if message then
        error(TAG .. ': assertRequired missing ' .. message)
    end

    -- Make sure all present packages are required.
    local message = false
    for package, _ in pairs(haveSet) do
        if not requireSet[package] then
            message = (message and message .. ', ' or '') .. package
        end
    end
    if message then
        error(TAG .. ': assertRequired have not-required ' .. message)
    end

end

-------------------------------------------------------------------------------
--- Lock CrLua packages.
--
-- @param tableName string : name of table being locked, or nil for CrLua.
-- @param table : table being locked, or nil for CrLua.
--
-- Make CrLua and nested packages read-only, with access requiring keys exist.
--
-- Locking rules:
--
-- (1.) '_data' is a reserved table name for mutable tables.  Do not lock.
--
-- (2.) If the table starts with a capital letter, make it read-only and
-- require keys exist.  These are packages or constants, attempting to access
-- a missing field is probably a typo.  (Override by adding an
-- _allowMissingKeys = { 'tableName1', 'tableName2'} entry at the same level
-- as the referenced tables.  Such tables allow reads to missing keys, as well
-- as all sub-tables in them.)
--
-- (2.) Otherwise make it read-only but allow reads to missing keys (value nil).
-- One can query membership by checking if a key exists.
--
-- This helps catch typos calling non-existent functions, or overwriting
-- a constant value by mistake.
-------------------------------------------------------------------------------
function CrLua.lock(tableName, table)
    local seen = {}

    local function lockRecursive(tableName, table, allowMissingKeys)
        assert(type(tableName) == 'string' and type(table) == 'table' and type(allowMissingKeys) == 'boolean')

        -- Watch out for cycles!  This might happen if a script defines
        -- an enum table, then later uses one of them in a different table.
        if seen[table] then
            return
        end
        seen[table] = true

        -- Leave _data tables alone.
        local isData = tableName == '_data'
        if isData then
            return
        end

        -- Get any missing keys entry BEFORE locking this table.
        local allowMissingKeysTableNameSet = {}
        if table._allowMissingKeys then
            for _, tableName in ipairs(table._allowMissingKeys) do
                allowMissingKeysTableNameSet[tableName] = true
            end
        end

        -- Lock the given table.
        local firstLetter = string.match(tableName, '%a')
        local isUpper = firstLetter and firstLetter == string.upper(firstLetter)
        if isUpper and not allowMissingKeys then
            CrLua.LockTable.readOnlyRequireKey(tableName, table)
        else
            CrLua.LockTable.readOnly(tableName, table)
        end

        -- Lock sub-tables, respecting _allowMissingKeys values.
        for k, v in pairs(table) do
            if type(v) == 'table' then
                local entryAllowMissingKeys = allowMissingKeys or allowMissingKeysTableNameSet[k] or false
                lockRecursive(tostring(k), v, entryAllowMissingKeys)
            end
        end
    end

    lockRecursive(tableName or 'CrLua', table or CrLua, false)
end

-- ############################################################################
-- #### END #include <~/CrLua/CrLua>
-- ############################################################################

-- ############################################################################
-- #### START #include <~/CrLua/LockGlobals>
-- ############################################################################

-------------------------------------------------------------------------------
--- Partially lock the _G global variable table.
-- Include this AFTER creating any necessary globals to prevent new ones.
--
-- - Existing globals can still be read AND WRITTEN.
-- - Cannot read non-existent globals.
-- - Cannot write new globals.
--
-- This helps catch typos where what was meant to access a local instead
-- references a (hopefully non-existent) global, as well as forgetting to use
-- "local" when creating objects.
--
-- @author Darrell
-------------------------------------------------------------------------------

local TAG = 'CrLua.LockGlobals'
local _lockGlobalsMetaTable = {}

-- Index is only called when the key does not already exist.
function _lockGlobalsMetaTable.__index(table, key)
    error(TAG .. ': accessing missing global "' .. tostring(key or '<nil>') .. '", typo?', 2)
end

function _lockGlobalsMetaTable.__newindex(table, key, value)
    error(TAG .. ': globals are locked, cannot create global variable "' .. tostring(key or '<nil>') .. '"', 2)
end

setmetatable(_G, _lockGlobalsMetaTable)

-------------------------------------------------------------------------------

-- Add a test function to the CrLua "namespace".
CrLua = CrLua or {}  -- global, <include> wraps in a do .. end block
CrLua.LockGlobals = assert(not CrLua.LockGlobals) and {
    _require = { 'LockGlobals' }  -- require self to avoid missing require error
}

-- ############################################################################
-- #### END #include <~/CrLua/LockGlobals>
-- ############################################################################

-- ############################################################################
-- #### START #include <~/CrLua/LockTable>
-- ############################################################################

-------------------------------------------------------------------------------
--- Access control for tables.
--
-- Locked tables are empty, using a metatable to detect and redirect all forms
-- of access to the actual table data.  Metatables contain a few custom fields:
-- - '_name' string table name.
-- - '_attrSet' table from set attribute names to true.
-- - '_tableContents' table holding the actual locked table content.
--
-- @author Darrell
-------------------------------------------------------------------------------

local TAG = 'CrLua.LockTable'

CrLua = CrLua or {}  -- global, <include> wraps in a do .. end block
CrLua.LockTable = assert(not CrLua.LockTable) and {
    _require = {}
}

CrLua.LockTable.ATTR = {
    READ_ONLY = 1,
    REQUIRE_KEY = 2
}

CrLua.LockTable.ACCESS_TYPE = {
    READ_MISSING = 'read missing',
    WRITE_NEW = 'write new',
    OVERWRITE = 'overwrite'
}

-------------------------------------------------------------------------------
--- Error and stop script when misusing a locked table.
-------------------------------------------------------------------------------
function CrLua.LockTable._error(lockedTable, key, accessType)
    assert(type(lockedTable) == 'table' and type(accessType) == 'string')
    local metatable = assert(getmetatable(lockedTable))
    local tableName = assert(metatable._name)
    local keyName = tostring(key or '<nil>')
    error(TAG .. ': ' .. accessType .. ' ' .. tableName .. '.' .. keyName)
end

-------------------------------------------------------------------------------
--- Create a new table with the lock table metamethods.
-- @param tableName string : use this as the tableName.key when reporting errors.
-- @param attrs table : list of LockTable.ATTRS to apply.
-- @param table : table to lock (this table itself is mutated!)
-- @return table : the same table, returned for create-by-wrapping convenience.
-------------------------------------------------------------------------------
function CrLua.LockTable._apply(tableName, attrs, table)
    assert(type(tableName) == 'string' and type(attrs) == 'table' and type(table) == 'table')

    -- Do not attempt to lock a table that already has a metatable.
    assert(not getmetatable(table), 'cannot apply LockTable when a metatable is already set: ' .. tableName)

    local newMetaTable = {
        _name = tableName,
        _attrSet = {},
        _tableContents = {}
    }

    -- Add the metatable methods to behave like the original table.
    for k, v in pairs(CrLua.LockTable._metatable) do
        newMetaTable[k] = v
    end

    -- Apply attrs.
    for _, attr in ipairs(attrs) do
        assert(type(attr) == 'number')
        newMetaTable._attrSet[attr] = true
    end

    -- Move table contents.
    for k, v in pairs(table) do
        newMetaTable._tableContents[k] = v
        table[k] = nil
    end

    setmetatable(table, newMetaTable)
    return table
end

CrLua.LockTable._metatable = {}

function CrLua.LockTable._metatable.__index(lockedTable, key)
    local metatable = getmetatable(lockedTable)
    local attrSet = metatable._attrSet
    local tableContents = metatable._tableContents
    local value = tableContents[key]
    local existing = value ~= nil
    if not existing and attrSet[CrLua.LockTable.ATTR.REQUIRE_KEY] then
        CrLua.LockTable._error(lockedTable, key, CrLua.LockTable.ACCESS_TYPE.READ_MISSING)
    end
    return value
end

function CrLua.LockTable._metatable.__newindex(lockedTable, key, value)
    local metatable = getmetatable(lockedTable)
    local attrSet = metatable._attrSet
    local tableContents = metatable._tableContents
    local existing = tableContents[key] ~= nil
    if attrSet[CrLua.LockTable.ATTR.READ_ONLY] then
        local accessType = existing and CrLua.LockTable.ACCESS_TYPE.OVERWRITE or CrLua.LockTable.ACCESS_TYPE.WRITE_NEW
        CrLua.LockTable._error(lockedTable, key, accessType)
    elseif not existing and attrSet[CrLua.LockTable.ATTR.REQUIRE_KEY] then
        CrLua.LockTable._error(lockedTable, key, CrLua.LockTable.ACCESS_TYPE.WRITE_NEW)
    end
    tableContents[key] = value
end

function CrLua.LockTable._metatable.__pairs(lockedTable)
    local metatable = getmetatable(lockedTable)
    local tableContents = metatable._tableContents
    local function iter(_, k)
        local k, v = next(tableContents, k)
        if v ~= nil then
            return k, v
        end
    end
    return iter, lockedTable, nil
end

function CrLua.LockTable._metatable.__ipairs(lockedTable)
    local metatable = getmetatable(lockedTable)
    local tableContents = metatable._tableContents
    local function iter(_, i)
        local v = tableContents[i + 1]
        if v ~= nil then
            return i + 1, v
        end
    end
    return iter, lockedTable, 0
end

function CrLua.LockTable._metatable.__len(lockedTable)
    local metatable = getmetatable(lockedTable)
    local tableContents = metatable._tableContents
    return #tableContents
end

-------------------------------------------------------------------------------
--- Make table read-only.
-- Reads to missing values return nil, as normal.
-- If the table has a _name entry, use that when reporting errors.
-- @param table
-- @param table : the same table as the argument for convenience assignment.
-------------------------------------------------------------------------------
function CrLua.LockTable.readOnly(tableName, table)
    assert(type(tableName) == 'string' and type(table) == 'table')
    assert(type(table) == 'table')

    local attrs = { CrLua.LockTable.ATTR.READ_ONLY }
    return CrLua.LockTable._apply(tableName, attrs, table)
end

-------------------------------------------------------------------------------
--- Make table read-only, and error if accessing missing key.
-- Helps catch typos reading from must-have-item tables.
-- @param table
-- @param table : the same table as the argument for convenience assignment.
-------------------------------------------------------------------------------
function CrLua.LockTable.readOnlyRequireKey(tableName, table)
    assert(type(tableName) == 'string' and type(table) == 'table')

    local attrs = { CrLua.LockTable.ATTR.READ_ONLY, CrLua.LockTable.ATTR.REQUIRE_KEY }
    return CrLua.LockTable._apply(tableName, attrs, table)
end

-- ############################################################################
-- #### END #include <~/CrLua/LockTable>
-- ############################################################################

-- ############################################################################
-- #### START #include <~/CrLua/Log>
-- ############################################################################

-------------------------------------------------------------------------------
--- Lua logging functions
-- @author Darrell
-------------------------------------------------------------------------------

local TAG = 'CrLua.Log'

CrLua = CrLua or {}  -- global, <include> wraps in a do .. end block
CrLua.Log = assert(not CrLua.Log) and {
    _require = {},
    _data = {}
}

CrLua.Log.LOG_LEVEL = {
    DEBUG = { level = 1, shortString = 'd' },
    INFO = { level = 2, shortString = 'i' },
    WARNING = { level = 3, shortString = 'w' },
	ERROR = { level = 4, shortString = 'e' },
    NONE = { level = 5, shortString = 'x' },
}

-- Store mutable level in a nested table to avoid mutating anything in Log.
CrLua.Log._data.level = CrLua.Log.LOG_LEVEL.NONE

-------------------------------------------------------------------------------
--- Set the log level, only log messagees at this level and above.
-- @param level table : CrLua.Log.LOG_LEVEL value.
-------------------------------------------------------------------------------
function CrLua.Log.setLogLevel(level)
    assert(level and type(level.level) == 'number' and type(level.shortString) == 'string')
    CrLua.Log._data.level = level
end

function CrLua.Log._logTable(message, table, depth)
    assert(type(message) == 'string' and type(table) == 'table' and type(depth) == 'number')

    local indent = '   '
    local prefix = ''
    if depth > 1 then
        for i = 2, depth do
            prefix = prefix .. indent
        end
    end
    local indentedPrefix = prefix .. '   '

    print(prefix .. message .. ' = {')
    if depth < 4 then
        for k, v in pairs(table) do
            if type(v) == 'table' then
                CrLua.Log._logTable(tostring(k), v, depth + 1)
            else
                print(indentedPrefix .. tostring(k) .. ' = ' .. tostring(v))
            end
        end
    else
        -- Stop once too deep (also prevents infinite loops if cycles).
        print(indentedPrefix .. '...')
    end
    print(prefix .. '}')
end

function CrLua.Log._log(logLevel, tag, message, table)
    -- Be verbose about bad arguments here, easy to pass the wrong item.
    -- ALWAYS verify arguments even if log level will suppress logging,
    -- otherwise bugs can creep in that only tickle when logging is enabled.
    if type(tag) ~= 'string' then
        error(TAG .. '_log: tag is not a string', 2)
    elseif type(message) ~= 'string' then
        error(TAG .. '_log: message is not a string', 2)
    elseif table and type(table) ~= 'table' then
        error(TAG .. '_log: table is not a table', 2)
    end

    if logLevel.level < CrLua.Log._data.level.level then
        return
    end

    -- Insert the tag as message prefix.
    message = tag .. ' ' .. message

    -- Inject a [timestamp/level] prefix.
    local timestamp = os.date('%I:%M.%S')
    message = '[' .. timestamp .. '/' .. logLevel.shortString .. '] ' .. message

    if table then
        CrLua.Log._logTable(message, table, 1)
    else
        print(message)
    end
end

-------------------------------------------------------------------------------
--- Log a debug message.
-- @param tag string.
-- @param message string.
-- @table optional table, logging contents if given.
-------------------------------------------------------------------------------
function CrLua.Log.d(tag, message, table)
    CrLua.Log._log(CrLua.Log.LOG_LEVEL.DEBUG, tag, message, table)
end

-- ############################################################################
-- #### END #include <~/CrLua/Log>
-- ############################################################################

-- ############################################################################
-- #### START #include <~/CrLua/Table>
-- ############################################################################

-------------------------------------------------------------------------------
--- Lua table utility functions
-- @author Darrell
-------------------------------------------------------------------------------

local TAG = 'CrLua.Table'

CrLua = CrLua or {}  -- global, <include> wraps in a do .. end block
CrLua.Table = assert(not CrLua.Table) and {
    _require = {}
}

-------------------------------------------------------------------------------
--- Merge two tables.
-- If tables have any keys in common, result value is from b.
-- @param a table
-- @param b table
-- @return table with both a and b key->value entries.
-------------------------------------------------------------------------------
function CrLua.Table.join(a, b)
    assert(type(a) == 'table' and type(b) == 'table')

    local result = {}
    for k, v in pairs(a) do
        result[k] = v
    end
    for k, v in pairs(b) do
        result[k] = v
    end
    return result
end

-- ############################################################################
-- #### END #include <~/CrLua/Table>
-- ############################################################################

-- ############################################################################
-- #### START #include <~/CrLua/TTS/HelperClient>
-- ############################################################################

-------------------------------------------------------------------------------
--- Connect to a remote "Helper" object..
-- @author Darrell
-------------------------------------------------------------------------------

local TAG = 'CrLua.TTS.HelperClient'

CrLua = CrLua or {}  -- global, <include> wraps in a do .. end block
CrLua.TTS = CrLua.TTS or {}
CrLua.TTS.HelperClient = assert(not CrLua.TTS.HelperClient) and {
    _require = {}
}

function CrLua.TTS.HelperClient.get(helperObjectName)
    local function getHelperObject()
        for _, object in ipairs(getAllObjects()) do
            if object.getName() == helperObjectName then return object end
        end
        error('missing object "' .. helperObjectName .. '"')
    end
    local helperObject = false
    local function getCallWrapper(functionName)
        helperObject = helperObject or getHelperObject()
        if not helperObject.getVar(functionName) then error('missing ' .. helperObjectName .. '.' .. functionName) end
        return function(parameters) return helperObject.call(functionName, parameters) end
    end
    return setmetatable({}, { __index = function(t, k) return getCallWrapper(k) end })
end

-- ############################################################################
-- #### END #include <~/CrLua/TTS/HelperClient>
-- ############################################################################

--CrLua.Log.setLogLevel(CrLua.Log.LOG_LEVEL.DEBUG)
--#include <~/CrLua/UnitTest>
--CrLua.UnitTest.runTests('CrLua.TI4.System', CrLua.TI4.System, true)

CrLua.assertRequired({ 'Log', 'Table', 'TTS.HelperClient' })
CrLua.lock()

-- ############################################################################
-- #### END #include <~/CrLua/Objects/TI4_BuildArea>
-- ############################################################################